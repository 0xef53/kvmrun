// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: types/types.proto

package types

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MachineState int32

const (
	MachineState_NOSTATE   MachineState = 0
	MachineState_STARTING  MachineState = 1
	MachineState_RUNNING   MachineState = 2
	MachineState_PAUSED    MachineState = 3
	MachineState_SHUTDOWN  MachineState = 4
	MachineState_INACTIVE  MachineState = 5
	MachineState_CRASHED   MachineState = 6
	MachineState_INCOMING  MachineState = 7
	MachineState_MIGRATING MachineState = 8
	MachineState_MIGRATED  MachineState = 9
)

var MachineState_name = map[int32]string{
	0: "NOSTATE",
	1: "STARTING",
	2: "RUNNING",
	3: "PAUSED",
	4: "SHUTDOWN",
	5: "INACTIVE",
	6: "CRASHED",
	7: "INCOMING",
	8: "MIGRATING",
	9: "MIGRATED",
}

var MachineState_value = map[string]int32{
	"NOSTATE":   0,
	"STARTING":  1,
	"RUNNING":   2,
	"PAUSED":    3,
	"SHUTDOWN":  4,
	"INACTIVE":  5,
	"CRASHED":   6,
	"INCOMING":  7,
	"MIGRATING": 8,
	"MIGRATED":  9,
}

func (x MachineState) String() string {
	return proto.EnumName(MachineState_name, int32(x))
}

func (MachineState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{0}
}

type NetIfaceDriver int32

const (
	NetIfaceDriver_UNDEFINED_NET_DRIVER NetIfaceDriver = 0
	NetIfaceDriver_VIRTIO_NET_PCI       NetIfaceDriver = 1
	NetIfaceDriver_RTL8139              NetIfaceDriver = 2
	NetIfaceDriver_E1000                NetIfaceDriver = 3
)

var NetIfaceDriver_name = map[int32]string{
	0: "UNDEFINED_NET_DRIVER",
	1: "VIRTIO_NET_PCI",
	2: "RTL8139",
	3: "E1000",
}

var NetIfaceDriver_value = map[string]int32{
	"UNDEFINED_NET_DRIVER": 0,
	"VIRTIO_NET_PCI":       1,
	"RTL8139":              2,
	"E1000":                3,
}

func (x NetIfaceDriver) String() string {
	return proto.EnumName(NetIfaceDriver_name, int32(x))
}

func (NetIfaceDriver) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{1}
}

type NetIfaceLinkState int32

const (
	NetIfaceLinkState_UNDEFINED_LINK_STATE NetIfaceLinkState = 0
	NetIfaceLinkState_UP                   NetIfaceLinkState = 1
	NetIfaceLinkState_DOWN                 NetIfaceLinkState = 2
)

var NetIfaceLinkState_name = map[int32]string{
	0: "UNDEFINED_LINK_STATE",
	1: "UP",
	2: "DOWN",
}

var NetIfaceLinkState_value = map[string]int32{
	"UNDEFINED_LINK_STATE": 0,
	"UP":                   1,
	"DOWN":                 2,
}

func (x NetIfaceLinkState) String() string {
	return proto.EnumName(NetIfaceLinkState_name, int32(x))
}

func (NetIfaceLinkState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{2}
}

type DiskDriver int32

const (
	DiskDriver_UNDEFINED_DISK_DRIVER DiskDriver = 0
	DiskDriver_VIRTIO_BLK_PCI        DiskDriver = 1
	DiskDriver_SCSI_HD               DiskDriver = 2
	DiskDriver_IDE_HD                DiskDriver = 3
)

var DiskDriver_name = map[int32]string{
	0: "UNDEFINED_DISK_DRIVER",
	1: "VIRTIO_BLK_PCI",
	2: "SCSI_HD",
	3: "IDE_HD",
}

var DiskDriver_value = map[string]int32{
	"UNDEFINED_DISK_DRIVER": 0,
	"VIRTIO_BLK_PCI":        1,
	"SCSI_HD":               2,
	"IDE_HD":                3,
}

func (x DiskDriver) String() string {
	return proto.EnumName(DiskDriver_name, int32(x))
}

func (DiskDriver) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{3}
}

type CdromDriver int32

const (
	CdromDriver_UNDEFINED_CDROM_DRIVER CdromDriver = 0
	CdromDriver_SCSI_CD                CdromDriver = 1
	CdromDriver_IDE_CD                 CdromDriver = 2
)

var CdromDriver_name = map[int32]string{
	0: "UNDEFINED_CDROM_DRIVER",
	1: "SCSI_CD",
	2: "IDE_CD",
}

var CdromDriver_value = map[string]int32{
	"UNDEFINED_CDROM_DRIVER": 0,
	"SCSI_CD":                1,
	"IDE_CD":                 2,
}

func (x CdromDriver) String() string {
	return proto.EnumName(CdromDriver_name, int32(x))
}

func (CdromDriver) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{4}
}

type InputDeviceType int32

const (
	InputDeviceType_UNDEFINED_INPUT_TYPE InputDeviceType = 0
	InputDeviceType_USB_TABLET           InputDeviceType = 1
)

var InputDeviceType_name = map[int32]string{
	0: "UNDEFINED_INPUT_TYPE",
	1: "USB_TABLET",
}

var InputDeviceType_value = map[string]int32{
	"UNDEFINED_INPUT_TYPE": 0,
	"USB_TABLET":           1,
}

func (x InputDeviceType) String() string {
	return proto.EnumName(InputDeviceType_name, int32(x))
}

func (InputDeviceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{5}
}

type TaskInfo_TaskState int32

const (
	TaskInfo_UNKNOWN   TaskInfo_TaskState = 0
	TaskInfo_RUNNING   TaskInfo_TaskState = 1
	TaskInfo_COMPLETED TaskInfo_TaskState = 2
	TaskInfo_FAILED    TaskInfo_TaskState = 3
)

var TaskInfo_TaskState_name = map[int32]string{
	0: "UNKNOWN",
	1: "RUNNING",
	2: "COMPLETED",
	3: "FAILED",
}

var TaskInfo_TaskState_value = map[string]int32{
	"UNKNOWN":   0,
	"RUNNING":   1,
	"COMPLETED": 2,
	"FAILED":    3,
}

func (x TaskInfo_TaskState) String() string {
	return proto.EnumName(TaskInfo_TaskState_name, int32(x))
}

func (TaskInfo_TaskState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{2, 0}
}

type MachineOpts struct {
	MachineType          string                      `protobuf:"bytes,1,opt,name=machine_type,json=machineType,proto3" json:"machine_type,omitempty"`
	Firmware             *MachineOpts_Firmware       `protobuf:"bytes,2,opt,name=firmware,proto3" json:"firmware,omitempty"`
	Memory               *MachineOpts_Memory         `protobuf:"bytes,3,opt,name=memory,proto3" json:"memory,omitempty"`
	CPU                  *MachineOpts_CPU            `protobuf:"bytes,4,opt,name=cpu,proto3" json:"cpu,omitempty"`
	HostPCIDevices       []*MachineOpts_HostPCI      `protobuf:"bytes,5,rep,name=hostpci,proto3" json:"hostpci,omitempty"`
	Inputs               []*MachineOpts_InputDevice  `protobuf:"bytes,6,rep,name=inputs,proto3" json:"inputs,omitempty"`
	Cdrom                []*MachineOpts_Cdrom        `protobuf:"bytes,7,rep,name=cdrom,proto3" json:"cdrom,omitempty"`
	Storage              []*MachineOpts_Disk         `protobuf:"bytes,8,rep,name=storage,proto3" json:"storage,omitempty"`
	Network              []*MachineOpts_NetIface     `protobuf:"bytes,9,rep,name=network,proto3" json:"network,omitempty"`
	VSockDev             *MachineOpts_VirtioVSock    `protobuf:"bytes,10,opt,name=vsock_device,json=vsockDevice,proto3" json:"vsock_device,omitempty"`
	CIDrive              *MachineOpts_CloudInit      `protobuf:"bytes,11,opt,name=cloudinit_drive,json=cloudinitDrive,proto3" json:"cloudinit_drive,omitempty"`
	Kernel               *MachineOpts_Kernel         `protobuf:"bytes,12,opt,name=kernel,proto3" json:"kernel,omitempty"`
	Proxy                []*MachineOpts_BackendProxy `protobuf:"bytes,13,rep,name=proxy,proto3" json:"proxy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *MachineOpts) Reset()         { *m = MachineOpts{} }
func (m *MachineOpts) String() string { return proto.CompactTextString(m) }
func (*MachineOpts) ProtoMessage()    {}
func (*MachineOpts) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{0}
}
func (m *MachineOpts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MachineOpts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MachineOpts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MachineOpts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MachineOpts.Merge(m, src)
}
func (m *MachineOpts) XXX_Size() int {
	return m.Size()
}
func (m *MachineOpts) XXX_DiscardUnknown() {
	xxx_messageInfo_MachineOpts.DiscardUnknown(m)
}

var xxx_messageInfo_MachineOpts proto.InternalMessageInfo

func (m *MachineOpts) GetMachineType() string {
	if m != nil {
		return m.MachineType
	}
	return ""
}

func (m *MachineOpts) GetFirmware() *MachineOpts_Firmware {
	if m != nil {
		return m.Firmware
	}
	return nil
}

func (m *MachineOpts) GetMemory() *MachineOpts_Memory {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *MachineOpts) GetCPU() *MachineOpts_CPU {
	if m != nil {
		return m.CPU
	}
	return nil
}

func (m *MachineOpts) GetHostPCIDevices() []*MachineOpts_HostPCI {
	if m != nil {
		return m.HostPCIDevices
	}
	return nil
}

func (m *MachineOpts) GetInputs() []*MachineOpts_InputDevice {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *MachineOpts) GetCdrom() []*MachineOpts_Cdrom {
	if m != nil {
		return m.Cdrom
	}
	return nil
}

func (m *MachineOpts) GetStorage() []*MachineOpts_Disk {
	if m != nil {
		return m.Storage
	}
	return nil
}

func (m *MachineOpts) GetNetwork() []*MachineOpts_NetIface {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *MachineOpts) GetVSockDev() *MachineOpts_VirtioVSock {
	if m != nil {
		return m.VSockDev
	}
	return nil
}

func (m *MachineOpts) GetCIDrive() *MachineOpts_CloudInit {
	if m != nil {
		return m.CIDrive
	}
	return nil
}

func (m *MachineOpts) GetKernel() *MachineOpts_Kernel {
	if m != nil {
		return m.Kernel
	}
	return nil
}

func (m *MachineOpts) GetProxy() []*MachineOpts_BackendProxy {
	if m != nil {
		return m.Proxy
	}
	return nil
}

type MachineOpts_Firmware struct {
	Image                string   `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MachineOpts_Firmware) Reset()         { *m = MachineOpts_Firmware{} }
func (m *MachineOpts_Firmware) String() string { return proto.CompactTextString(m) }
func (*MachineOpts_Firmware) ProtoMessage()    {}
func (*MachineOpts_Firmware) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{0, 0}
}
func (m *MachineOpts_Firmware) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MachineOpts_Firmware) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MachineOpts_Firmware.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MachineOpts_Firmware) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MachineOpts_Firmware.Merge(m, src)
}
func (m *MachineOpts_Firmware) XXX_Size() int {
	return m.Size()
}
func (m *MachineOpts_Firmware) XXX_DiscardUnknown() {
	xxx_messageInfo_MachineOpts_Firmware.DiscardUnknown(m)
}

var xxx_messageInfo_MachineOpts_Firmware proto.InternalMessageInfo

func (m *MachineOpts_Firmware) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

type MachineOpts_Memory struct {
	Actual               int64    `protobuf:"varint,1,opt,name=actual,proto3" json:"actual,omitempty"`
	Total                int64    `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MachineOpts_Memory) Reset()         { *m = MachineOpts_Memory{} }
func (m *MachineOpts_Memory) String() string { return proto.CompactTextString(m) }
func (*MachineOpts_Memory) ProtoMessage()    {}
func (*MachineOpts_Memory) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{0, 1}
}
func (m *MachineOpts_Memory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MachineOpts_Memory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MachineOpts_Memory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MachineOpts_Memory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MachineOpts_Memory.Merge(m, src)
}
func (m *MachineOpts_Memory) XXX_Size() int {
	return m.Size()
}
func (m *MachineOpts_Memory) XXX_DiscardUnknown() {
	xxx_messageInfo_MachineOpts_Memory.DiscardUnknown(m)
}

var xxx_messageInfo_MachineOpts_Memory proto.InternalMessageInfo

func (m *MachineOpts_Memory) GetActual() int64 {
	if m != nil {
		return m.Actual
	}
	return 0
}

func (m *MachineOpts_Memory) GetTotal() int64 {
	if m != nil {
		return m.Total
	}
	return 0
}

type MachineOpts_CPU struct {
	Actual               int64    `protobuf:"varint,1,opt,name=actual,proto3" json:"actual,omitempty"`
	Total                int64    `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
	Sockets              int32    `protobuf:"varint,3,opt,name=sockets,proto3" json:"sockets,omitempty"`
	Model                string   `protobuf:"bytes,4,opt,name=model,proto3" json:"model,omitempty"`
	Quota                int64    `protobuf:"varint,5,opt,name=quota,proto3" json:"quota,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MachineOpts_CPU) Reset()         { *m = MachineOpts_CPU{} }
func (m *MachineOpts_CPU) String() string { return proto.CompactTextString(m) }
func (*MachineOpts_CPU) ProtoMessage()    {}
func (*MachineOpts_CPU) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{0, 2}
}
func (m *MachineOpts_CPU) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MachineOpts_CPU) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MachineOpts_CPU.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MachineOpts_CPU) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MachineOpts_CPU.Merge(m, src)
}
func (m *MachineOpts_CPU) XXX_Size() int {
	return m.Size()
}
func (m *MachineOpts_CPU) XXX_DiscardUnknown() {
	xxx_messageInfo_MachineOpts_CPU.DiscardUnknown(m)
}

var xxx_messageInfo_MachineOpts_CPU proto.InternalMessageInfo

func (m *MachineOpts_CPU) GetActual() int64 {
	if m != nil {
		return m.Actual
	}
	return 0
}

func (m *MachineOpts_CPU) GetTotal() int64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *MachineOpts_CPU) GetSockets() int32 {
	if m != nil {
		return m.Sockets
	}
	return 0
}

func (m *MachineOpts_CPU) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *MachineOpts_CPU) GetQuota() int64 {
	if m != nil {
		return m.Quota
	}
	return 0
}

type MachineOpts_HostPCI struct {
	Addr                 string   `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	Multifunction        bool     `protobuf:"varint,2,opt,name=multifunction,proto3" json:"multifunction,omitempty"`
	PrimaryGPU           bool     `protobuf:"varint,3,opt,name=primary_gpu,json=primaryGpu,proto3" json:"primary_gpu,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MachineOpts_HostPCI) Reset()         { *m = MachineOpts_HostPCI{} }
func (m *MachineOpts_HostPCI) String() string { return proto.CompactTextString(m) }
func (*MachineOpts_HostPCI) ProtoMessage()    {}
func (*MachineOpts_HostPCI) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{0, 3}
}
func (m *MachineOpts_HostPCI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MachineOpts_HostPCI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MachineOpts_HostPCI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MachineOpts_HostPCI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MachineOpts_HostPCI.Merge(m, src)
}
func (m *MachineOpts_HostPCI) XXX_Size() int {
	return m.Size()
}
func (m *MachineOpts_HostPCI) XXX_DiscardUnknown() {
	xxx_messageInfo_MachineOpts_HostPCI.DiscardUnknown(m)
}

var xxx_messageInfo_MachineOpts_HostPCI proto.InternalMessageInfo

func (m *MachineOpts_HostPCI) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *MachineOpts_HostPCI) GetMultifunction() bool {
	if m != nil {
		return m.Multifunction
	}
	return false
}

func (m *MachineOpts_HostPCI) GetPrimaryGPU() bool {
	if m != nil {
		return m.PrimaryGPU
	}
	return false
}

type MachineOpts_InputDevice struct {
	Type                 string   `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MachineOpts_InputDevice) Reset()         { *m = MachineOpts_InputDevice{} }
func (m *MachineOpts_InputDevice) String() string { return proto.CompactTextString(m) }
func (*MachineOpts_InputDevice) ProtoMessage()    {}
func (*MachineOpts_InputDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{0, 4}
}
func (m *MachineOpts_InputDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MachineOpts_InputDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MachineOpts_InputDevice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MachineOpts_InputDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MachineOpts_InputDevice.Merge(m, src)
}
func (m *MachineOpts_InputDevice) XXX_Size() int {
	return m.Size()
}
func (m *MachineOpts_InputDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_MachineOpts_InputDevice.DiscardUnknown(m)
}

var xxx_messageInfo_MachineOpts_InputDevice proto.InternalMessageInfo

func (m *MachineOpts_InputDevice) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type MachineOpts_Cdrom struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Media                string   `protobuf:"bytes,2,opt,name=media,proto3" json:"media,omitempty"`
	Driver               string   `protobuf:"bytes,3,opt,name=driver,proto3" json:"driver,omitempty"`
	ReadOnly             bool     `protobuf:"varint,4,opt,name=readonly,proto3" json:"readonly,omitempty"`
	Addr                 string   `protobuf:"bytes,5,opt,name=addr,proto3" json:"addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MachineOpts_Cdrom) Reset()         { *m = MachineOpts_Cdrom{} }
func (m *MachineOpts_Cdrom) String() string { return proto.CompactTextString(m) }
func (*MachineOpts_Cdrom) ProtoMessage()    {}
func (*MachineOpts_Cdrom) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{0, 5}
}
func (m *MachineOpts_Cdrom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MachineOpts_Cdrom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MachineOpts_Cdrom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MachineOpts_Cdrom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MachineOpts_Cdrom.Merge(m, src)
}
func (m *MachineOpts_Cdrom) XXX_Size() int {
	return m.Size()
}
func (m *MachineOpts_Cdrom) XXX_DiscardUnknown() {
	xxx_messageInfo_MachineOpts_Cdrom.DiscardUnknown(m)
}

var xxx_messageInfo_MachineOpts_Cdrom proto.InternalMessageInfo

func (m *MachineOpts_Cdrom) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MachineOpts_Cdrom) GetMedia() string {
	if m != nil {
		return m.Media
	}
	return ""
}

func (m *MachineOpts_Cdrom) GetDriver() string {
	if m != nil {
		return m.Driver
	}
	return ""
}

func (m *MachineOpts_Cdrom) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *MachineOpts_Cdrom) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type MachineOpts_Disk struct {
	Path                 string   `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Driver               string   `protobuf:"bytes,2,opt,name=driver,proto3" json:"driver,omitempty"`
	IopsRd               int64    `protobuf:"varint,3,opt,name=iops_rd,json=iopsRd,proto3" json:"iops_rd,omitempty"`
	IopsWr               int64    `protobuf:"varint,4,opt,name=iops_wr,json=iopsWr,proto3" json:"iops_wr,omitempty"`
	Addr                 string   `protobuf:"bytes,5,opt,name=addr,proto3" json:"addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MachineOpts_Disk) Reset()         { *m = MachineOpts_Disk{} }
func (m *MachineOpts_Disk) String() string { return proto.CompactTextString(m) }
func (*MachineOpts_Disk) ProtoMessage()    {}
func (*MachineOpts_Disk) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{0, 6}
}
func (m *MachineOpts_Disk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MachineOpts_Disk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MachineOpts_Disk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MachineOpts_Disk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MachineOpts_Disk.Merge(m, src)
}
func (m *MachineOpts_Disk) XXX_Size() int {
	return m.Size()
}
func (m *MachineOpts_Disk) XXX_DiscardUnknown() {
	xxx_messageInfo_MachineOpts_Disk.DiscardUnknown(m)
}

var xxx_messageInfo_MachineOpts_Disk proto.InternalMessageInfo

func (m *MachineOpts_Disk) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *MachineOpts_Disk) GetDriver() string {
	if m != nil {
		return m.Driver
	}
	return ""
}

func (m *MachineOpts_Disk) GetIopsRd() int64 {
	if m != nil {
		return m.IopsRd
	}
	return 0
}

func (m *MachineOpts_Disk) GetIopsWr() int64 {
	if m != nil {
		return m.IopsWr
	}
	return 0
}

func (m *MachineOpts_Disk) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type MachineOpts_NetIface struct {
	Ifname               string   `protobuf:"bytes,1,opt,name=ifname,proto3" json:"ifname,omitempty"`
	Driver               string   `protobuf:"bytes,2,opt,name=driver,proto3" json:"driver,omitempty"`
	HwAddr               string   `protobuf:"bytes,3,opt,name=hw_addr,json=hwAddr,proto3" json:"hw_addr,omitempty"`
	Ifup                 string   `protobuf:"bytes,4,opt,name=ifup,proto3" json:"ifup,omitempty"`
	Ifdown               string   `protobuf:"bytes,5,opt,name=ifdown,proto3" json:"ifdown,omitempty"`
	Addr                 string   `protobuf:"bytes,6,opt,name=addr,proto3" json:"addr,omitempty"`
	Queues               uint32   `protobuf:"varint,7,opt,name=queues,proto3" json:"queues,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MachineOpts_NetIface) Reset()         { *m = MachineOpts_NetIface{} }
func (m *MachineOpts_NetIface) String() string { return proto.CompactTextString(m) }
func (*MachineOpts_NetIface) ProtoMessage()    {}
func (*MachineOpts_NetIface) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{0, 7}
}
func (m *MachineOpts_NetIface) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MachineOpts_NetIface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MachineOpts_NetIface.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MachineOpts_NetIface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MachineOpts_NetIface.Merge(m, src)
}
func (m *MachineOpts_NetIface) XXX_Size() int {
	return m.Size()
}
func (m *MachineOpts_NetIface) XXX_DiscardUnknown() {
	xxx_messageInfo_MachineOpts_NetIface.DiscardUnknown(m)
}

var xxx_messageInfo_MachineOpts_NetIface proto.InternalMessageInfo

func (m *MachineOpts_NetIface) GetIfname() string {
	if m != nil {
		return m.Ifname
	}
	return ""
}

func (m *MachineOpts_NetIface) GetDriver() string {
	if m != nil {
		return m.Driver
	}
	return ""
}

func (m *MachineOpts_NetIface) GetHwAddr() string {
	if m != nil {
		return m.HwAddr
	}
	return ""
}

func (m *MachineOpts_NetIface) GetIfup() string {
	if m != nil {
		return m.Ifup
	}
	return ""
}

func (m *MachineOpts_NetIface) GetIfdown() string {
	if m != nil {
		return m.Ifdown
	}
	return ""
}

func (m *MachineOpts_NetIface) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *MachineOpts_NetIface) GetQueues() uint32 {
	if m != nil {
		return m.Queues
	}
	return 0
}

type MachineOpts_VirtioVSock struct {
	Auto                 bool     `protobuf:"varint,1,opt,name=auto,proto3" json:"auto,omitempty"`
	ContextID            uint32   `protobuf:"varint,2,opt,name=context_id,json=contextId,proto3" json:"context_id,omitempty"`
	Addr                 string   `protobuf:"bytes,3,opt,name=addr,proto3" json:"addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MachineOpts_VirtioVSock) Reset()         { *m = MachineOpts_VirtioVSock{} }
func (m *MachineOpts_VirtioVSock) String() string { return proto.CompactTextString(m) }
func (*MachineOpts_VirtioVSock) ProtoMessage()    {}
func (*MachineOpts_VirtioVSock) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{0, 8}
}
func (m *MachineOpts_VirtioVSock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MachineOpts_VirtioVSock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MachineOpts_VirtioVSock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MachineOpts_VirtioVSock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MachineOpts_VirtioVSock.Merge(m, src)
}
func (m *MachineOpts_VirtioVSock) XXX_Size() int {
	return m.Size()
}
func (m *MachineOpts_VirtioVSock) XXX_DiscardUnknown() {
	xxx_messageInfo_MachineOpts_VirtioVSock.DiscardUnknown(m)
}

var xxx_messageInfo_MachineOpts_VirtioVSock proto.InternalMessageInfo

func (m *MachineOpts_VirtioVSock) GetAuto() bool {
	if m != nil {
		return m.Auto
	}
	return false
}

func (m *MachineOpts_VirtioVSock) GetContextID() uint32 {
	if m != nil {
		return m.ContextID
	}
	return 0
}

func (m *MachineOpts_VirtioVSock) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type MachineOpts_CloudInit struct {
	Path                 string   `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MachineOpts_CloudInit) Reset()         { *m = MachineOpts_CloudInit{} }
func (m *MachineOpts_CloudInit) String() string { return proto.CompactTextString(m) }
func (*MachineOpts_CloudInit) ProtoMessage()    {}
func (*MachineOpts_CloudInit) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{0, 9}
}
func (m *MachineOpts_CloudInit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MachineOpts_CloudInit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MachineOpts_CloudInit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MachineOpts_CloudInit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MachineOpts_CloudInit.Merge(m, src)
}
func (m *MachineOpts_CloudInit) XXX_Size() int {
	return m.Size()
}
func (m *MachineOpts_CloudInit) XXX_DiscardUnknown() {
	xxx_messageInfo_MachineOpts_CloudInit.DiscardUnknown(m)
}

var xxx_messageInfo_MachineOpts_CloudInit proto.InternalMessageInfo

func (m *MachineOpts_CloudInit) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type MachineOpts_Kernel struct {
	Image                string   `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	Initrd               string   `protobuf:"bytes,2,opt,name=initrd,proto3" json:"initrd,omitempty"`
	Modiso               string   `protobuf:"bytes,3,opt,name=modiso,proto3" json:"modiso,omitempty"`
	Cmdline              string   `protobuf:"bytes,4,opt,name=cmdline,proto3" json:"cmdline,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MachineOpts_Kernel) Reset()         { *m = MachineOpts_Kernel{} }
func (m *MachineOpts_Kernel) String() string { return proto.CompactTextString(m) }
func (*MachineOpts_Kernel) ProtoMessage()    {}
func (*MachineOpts_Kernel) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{0, 10}
}
func (m *MachineOpts_Kernel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MachineOpts_Kernel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MachineOpts_Kernel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MachineOpts_Kernel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MachineOpts_Kernel.Merge(m, src)
}
func (m *MachineOpts_Kernel) XXX_Size() int {
	return m.Size()
}
func (m *MachineOpts_Kernel) XXX_DiscardUnknown() {
	xxx_messageInfo_MachineOpts_Kernel.DiscardUnknown(m)
}

var xxx_messageInfo_MachineOpts_Kernel proto.InternalMessageInfo

func (m *MachineOpts_Kernel) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *MachineOpts_Kernel) GetInitrd() string {
	if m != nil {
		return m.Initrd
	}
	return ""
}

func (m *MachineOpts_Kernel) GetModiso() string {
	if m != nil {
		return m.Modiso
	}
	return ""
}

func (m *MachineOpts_Kernel) GetCmdline() string {
	if m != nil {
		return m.Cmdline
	}
	return ""
}

type MachineOpts_BackendProxy struct {
	Path                 string            `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Command              string            `protobuf:"bytes,2,opt,name=command,proto3" json:"command,omitempty"`
	Envs                 map[string]string `protobuf:"bytes,3,rep,name=envs,proto3" json:"envs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *MachineOpts_BackendProxy) Reset()         { *m = MachineOpts_BackendProxy{} }
func (m *MachineOpts_BackendProxy) String() string { return proto.CompactTextString(m) }
func (*MachineOpts_BackendProxy) ProtoMessage()    {}
func (*MachineOpts_BackendProxy) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{0, 11}
}
func (m *MachineOpts_BackendProxy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MachineOpts_BackendProxy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MachineOpts_BackendProxy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MachineOpts_BackendProxy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MachineOpts_BackendProxy.Merge(m, src)
}
func (m *MachineOpts_BackendProxy) XXX_Size() int {
	return m.Size()
}
func (m *MachineOpts_BackendProxy) XXX_DiscardUnknown() {
	xxx_messageInfo_MachineOpts_BackendProxy.DiscardUnknown(m)
}

var xxx_messageInfo_MachineOpts_BackendProxy proto.InternalMessageInfo

func (m *MachineOpts_BackendProxy) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *MachineOpts_BackendProxy) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *MachineOpts_BackendProxy) GetEnvs() map[string]string {
	if m != nil {
		return m.Envs
	}
	return nil
}

type Machine struct {
	Name                 string       `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Config               *MachineOpts `protobuf:"bytes,2,opt,name=config,proto3" json:"config,omitempty"`
	Runtime              *MachineOpts `protobuf:"bytes,3,opt,name=runtime,proto3" json:"runtime,omitempty"`
	Persistent           bool         `protobuf:"varint,4,opt,name=persistent,proto3" json:"persistent,omitempty"`
	State                MachineState `protobuf:"varint,5,opt,name=state,proto3,enum=kvmrun.api.types.MachineState" json:"state,omitempty"`
	Pid                  int32        `protobuf:"varint,6,opt,name=pid,proto3" json:"pid,omitempty"`
	LifeTime             int64        `protobuf:"varint,7,opt,name=life_time,json=lifeTime,proto3" json:"life_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Machine) Reset()         { *m = Machine{} }
func (m *Machine) String() string { return proto.CompactTextString(m) }
func (*Machine) ProtoMessage()    {}
func (*Machine) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{1}
}
func (m *Machine) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Machine) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Machine.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Machine) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Machine.Merge(m, src)
}
func (m *Machine) XXX_Size() int {
	return m.Size()
}
func (m *Machine) XXX_DiscardUnknown() {
	xxx_messageInfo_Machine.DiscardUnknown(m)
}

var xxx_messageInfo_Machine proto.InternalMessageInfo

func (m *Machine) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Machine) GetConfig() *MachineOpts {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *Machine) GetRuntime() *MachineOpts {
	if m != nil {
		return m.Runtime
	}
	return nil
}

func (m *Machine) GetPersistent() bool {
	if m != nil {
		return m.Persistent
	}
	return false
}

func (m *Machine) GetState() MachineState {
	if m != nil {
		return m.State
	}
	return MachineState_NOSTATE
}

func (m *Machine) GetPid() int32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *Machine) GetLifeTime() int64 {
	if m != nil {
		return m.LifeTime
	}
	return 0
}

type TaskInfo struct {
	Key       string             `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	State     TaskInfo_TaskState `protobuf:"varint,2,opt,name=state,proto3,enum=kvmrun.api.types.TaskInfo_TaskState" json:"state,omitempty"`
	StateDesc string             `protobuf:"bytes,3,opt,name=state_desc,json=stateDesc,proto3" json:"state_desc,omitempty"`
	Progress  int32              `protobuf:"varint,4,opt,name=progress,proto3" json:"progress,omitempty"`
	// Types that are valid to be assigned to Stat:
	//	*TaskInfo_Migration
	Stat                 isTaskInfo_Stat `protobuf_oneof:"stat"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *TaskInfo) Reset()         { *m = TaskInfo{} }
func (m *TaskInfo) String() string { return proto.CompactTextString(m) }
func (*TaskInfo) ProtoMessage()    {}
func (*TaskInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{2}
}
func (m *TaskInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskInfo.Merge(m, src)
}
func (m *TaskInfo) XXX_Size() int {
	return m.Size()
}
func (m *TaskInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TaskInfo proto.InternalMessageInfo

type isTaskInfo_Stat interface {
	isTaskInfo_Stat()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TaskInfo_Migration struct {
	Migration *TaskInfo_MigrationInfo `protobuf:"bytes,10,opt,name=migration,proto3,oneof" json:"migration,omitempty"`
}

func (*TaskInfo_Migration) isTaskInfo_Stat() {}

func (m *TaskInfo) GetStat() isTaskInfo_Stat {
	if m != nil {
		return m.Stat
	}
	return nil
}

func (m *TaskInfo) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *TaskInfo) GetState() TaskInfo_TaskState {
	if m != nil {
		return m.State
	}
	return TaskInfo_UNKNOWN
}

func (m *TaskInfo) GetStateDesc() string {
	if m != nil {
		return m.StateDesc
	}
	return ""
}

func (m *TaskInfo) GetProgress() int32 {
	if m != nil {
		return m.Progress
	}
	return 0
}

func (m *TaskInfo) GetMigration() *TaskInfo_MigrationInfo {
	if x, ok := m.GetStat().(*TaskInfo_Migration); ok {
		return x.Migration
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TaskInfo) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TaskInfo_Migration)(nil),
	}
}

type TaskInfo_MigrationInfo struct {
	DstServer            string                                  `protobuf:"bytes,1,opt,name=dst_server,json=dstServer,proto3" json:"dst_server,omitempty"`
	Qemu                 *TaskInfo_MigrationInfo_Stat            `protobuf:"bytes,2,opt,name=qemu,proto3" json:"qemu,omitempty"`
	Disks                map[string]*TaskInfo_MigrationInfo_Stat `protobuf:"bytes,3,rep,name=disks,proto3" json:"disks,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                                `json:"-"`
	XXX_unrecognized     []byte                                  `json:"-"`
	XXX_sizecache        int32                                   `json:"-"`
}

func (m *TaskInfo_MigrationInfo) Reset()         { *m = TaskInfo_MigrationInfo{} }
func (m *TaskInfo_MigrationInfo) String() string { return proto.CompactTextString(m) }
func (*TaskInfo_MigrationInfo) ProtoMessage()    {}
func (*TaskInfo_MigrationInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{2, 0}
}
func (m *TaskInfo_MigrationInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskInfo_MigrationInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskInfo_MigrationInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskInfo_MigrationInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskInfo_MigrationInfo.Merge(m, src)
}
func (m *TaskInfo_MigrationInfo) XXX_Size() int {
	return m.Size()
}
func (m *TaskInfo_MigrationInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskInfo_MigrationInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TaskInfo_MigrationInfo proto.InternalMessageInfo

func (m *TaskInfo_MigrationInfo) GetDstServer() string {
	if m != nil {
		return m.DstServer
	}
	return ""
}

func (m *TaskInfo_MigrationInfo) GetQemu() *TaskInfo_MigrationInfo_Stat {
	if m != nil {
		return m.Qemu
	}
	return nil
}

func (m *TaskInfo_MigrationInfo) GetDisks() map[string]*TaskInfo_MigrationInfo_Stat {
	if m != nil {
		return m.Disks
	}
	return nil
}

type TaskInfo_MigrationInfo_Stat struct {
	Total                uint64   `protobuf:"varint,1,opt,name=total,proto3" json:"total,omitempty"`
	Remaining            uint64   `protobuf:"varint,2,opt,name=remaining,proto3" json:"remaining,omitempty"`
	Transferred          uint64   `protobuf:"varint,3,opt,name=transferred,proto3" json:"transferred,omitempty"`
	Progress             int32    `protobuf:"varint,4,opt,name=progress,proto3" json:"progress,omitempty"`
	Speed                int32    `protobuf:"varint,5,opt,name=speed,proto3" json:"speed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TaskInfo_MigrationInfo_Stat) Reset()         { *m = TaskInfo_MigrationInfo_Stat{} }
func (m *TaskInfo_MigrationInfo_Stat) String() string { return proto.CompactTextString(m) }
func (*TaskInfo_MigrationInfo_Stat) ProtoMessage()    {}
func (*TaskInfo_MigrationInfo_Stat) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{2, 0, 0}
}
func (m *TaskInfo_MigrationInfo_Stat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskInfo_MigrationInfo_Stat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskInfo_MigrationInfo_Stat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskInfo_MigrationInfo_Stat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskInfo_MigrationInfo_Stat.Merge(m, src)
}
func (m *TaskInfo_MigrationInfo_Stat) XXX_Size() int {
	return m.Size()
}
func (m *TaskInfo_MigrationInfo_Stat) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskInfo_MigrationInfo_Stat.DiscardUnknown(m)
}

var xxx_messageInfo_TaskInfo_MigrationInfo_Stat proto.InternalMessageInfo

func (m *TaskInfo_MigrationInfo_Stat) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *TaskInfo_MigrationInfo_Stat) GetRemaining() uint64 {
	if m != nil {
		return m.Remaining
	}
	return 0
}

func (m *TaskInfo_MigrationInfo_Stat) GetTransferred() uint64 {
	if m != nil {
		return m.Transferred
	}
	return 0
}

func (m *TaskInfo_MigrationInfo_Stat) GetProgress() int32 {
	if m != nil {
		return m.Progress
	}
	return 0
}

func (m *TaskInfo_MigrationInfo_Stat) GetSpeed() int32 {
	if m != nil {
		return m.Speed
	}
	return 0
}

type MigrationOverrides struct {
	Name                 string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Disks                map[string]string `protobuf:"bytes,2,rep,name=disks,proto3" json:"disks,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *MigrationOverrides) Reset()         { *m = MigrationOverrides{} }
func (m *MigrationOverrides) String() string { return proto.CompactTextString(m) }
func (*MigrationOverrides) ProtoMessage()    {}
func (*MigrationOverrides) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{3}
}
func (m *MigrationOverrides) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MigrationOverrides) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MigrationOverrides.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MigrationOverrides) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MigrationOverrides.Merge(m, src)
}
func (m *MigrationOverrides) XXX_Size() int {
	return m.Size()
}
func (m *MigrationOverrides) XXX_DiscardUnknown() {
	xxx_messageInfo_MigrationOverrides.DiscardUnknown(m)
}

var xxx_messageInfo_MigrationOverrides proto.InternalMessageInfo

func (m *MigrationOverrides) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MigrationOverrides) GetDisks() map[string]string {
	if m != nil {
		return m.Disks
	}
	return nil
}

type IncomingMachineRequisites struct {
	IncomingPort         int32    `protobuf:"varint,1,opt,name=incoming_port,json=incomingPort,proto3" json:"incoming_port,omitempty"`
	NBDPort              int32    `protobuf:"varint,2,opt,name=nbd_port,json=nbdPort,proto3" json:"nbd_port,omitempty"`
	Pid                  int32    `protobuf:"varint,3,opt,name=pid,proto3" json:"pid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IncomingMachineRequisites) Reset()         { *m = IncomingMachineRequisites{} }
func (m *IncomingMachineRequisites) String() string { return proto.CompactTextString(m) }
func (*IncomingMachineRequisites) ProtoMessage()    {}
func (*IncomingMachineRequisites) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{4}
}
func (m *IncomingMachineRequisites) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IncomingMachineRequisites) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IncomingMachineRequisites.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IncomingMachineRequisites) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IncomingMachineRequisites.Merge(m, src)
}
func (m *IncomingMachineRequisites) XXX_Size() int {
	return m.Size()
}
func (m *IncomingMachineRequisites) XXX_DiscardUnknown() {
	xxx_messageInfo_IncomingMachineRequisites.DiscardUnknown(m)
}

var xxx_messageInfo_IncomingMachineRequisites proto.InternalMessageInfo

func (m *IncomingMachineRequisites) GetIncomingPort() int32 {
	if m != nil {
		return m.IncomingPort
	}
	return 0
}

func (m *IncomingMachineRequisites) GetNBDPort() int32 {
	if m != nil {
		return m.NBDPort
	}
	return 0
}

func (m *IncomingMachineRequisites) GetPid() int32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

type VNCRequisites struct {
	Password             string   `protobuf:"bytes,1,opt,name=password,proto3" json:"password,omitempty"`
	Display              int32    `protobuf:"varint,2,opt,name=display,proto3" json:"display,omitempty"`
	Port                 int32    `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
	WSPort               int32    `protobuf:"varint,4,opt,name=ws_port,json=wsPort,proto3" json:"ws_port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VNCRequisites) Reset()         { *m = VNCRequisites{} }
func (m *VNCRequisites) String() string { return proto.CompactTextString(m) }
func (*VNCRequisites) ProtoMessage()    {}
func (*VNCRequisites) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{5}
}
func (m *VNCRequisites) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VNCRequisites) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VNCRequisites.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VNCRequisites) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VNCRequisites.Merge(m, src)
}
func (m *VNCRequisites) XXX_Size() int {
	return m.Size()
}
func (m *VNCRequisites) XXX_DiscardUnknown() {
	xxx_messageInfo_VNCRequisites.DiscardUnknown(m)
}

var xxx_messageInfo_VNCRequisites proto.InternalMessageInfo

func (m *VNCRequisites) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *VNCRequisites) GetDisplay() int32 {
	if m != nil {
		return m.Display
	}
	return 0
}

func (m *VNCRequisites) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *VNCRequisites) GetWSPort() int32 {
	if m != nil {
		return m.WSPort
	}
	return 0
}

type MachineEvent struct {
	Type                 string                  `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Data                 []byte                  `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	Timestamp            *MachineEvent_Timestamp `protobuf:"bytes,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *MachineEvent) Reset()         { *m = MachineEvent{} }
func (m *MachineEvent) String() string { return proto.CompactTextString(m) }
func (*MachineEvent) ProtoMessage()    {}
func (*MachineEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{6}
}
func (m *MachineEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MachineEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MachineEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MachineEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MachineEvent.Merge(m, src)
}
func (m *MachineEvent) XXX_Size() int {
	return m.Size()
}
func (m *MachineEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_MachineEvent.DiscardUnknown(m)
}

var xxx_messageInfo_MachineEvent proto.InternalMessageInfo

func (m *MachineEvent) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *MachineEvent) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *MachineEvent) GetTimestamp() *MachineEvent_Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type MachineEvent_Timestamp struct {
	Seconds              uint64   `protobuf:"varint,1,opt,name=seconds,proto3" json:"seconds,omitempty"`
	Microseconds         uint64   `protobuf:"varint,2,opt,name=microseconds,proto3" json:"microseconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MachineEvent_Timestamp) Reset()         { *m = MachineEvent_Timestamp{} }
func (m *MachineEvent_Timestamp) String() string { return proto.CompactTextString(m) }
func (*MachineEvent_Timestamp) ProtoMessage()    {}
func (*MachineEvent_Timestamp) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{6, 0}
}
func (m *MachineEvent_Timestamp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MachineEvent_Timestamp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MachineEvent_Timestamp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MachineEvent_Timestamp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MachineEvent_Timestamp.Merge(m, src)
}
func (m *MachineEvent_Timestamp) XXX_Size() int {
	return m.Size()
}
func (m *MachineEvent_Timestamp) XXX_DiscardUnknown() {
	xxx_messageInfo_MachineEvent_Timestamp.DiscardUnknown(m)
}

var xxx_messageInfo_MachineEvent_Timestamp proto.InternalMessageInfo

func (m *MachineEvent_Timestamp) GetSeconds() uint64 {
	if m != nil {
		return m.Seconds
	}
	return 0
}

func (m *MachineEvent_Timestamp) GetMicroseconds() uint64 {
	if m != nil {
		return m.Microseconds
	}
	return 0
}

type NetworkEndPoint struct {
	LinkName  string `protobuf:"bytes,1,opt,name=link_name,json=linkName,proto3" json:"link_name,omitempty"`
	LinkIndex uint32 `protobuf:"varint,2,opt,name=link_index,json=linkIndex,proto3" json:"link_index,omitempty"`
	// Types that are valid to be assigned to Attrs:
	//	*NetworkEndPoint_VlanAttrs
	//	*NetworkEndPoint_VxlanAttrs
	//	*NetworkEndPoint_IPFabricAttrs
	Attrs                isNetworkEndPoint_Attrs `protobuf_oneof:"attrs"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *NetworkEndPoint) Reset()         { *m = NetworkEndPoint{} }
func (m *NetworkEndPoint) String() string { return proto.CompactTextString(m) }
func (*NetworkEndPoint) ProtoMessage()    {}
func (*NetworkEndPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{7}
}
func (m *NetworkEndPoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkEndPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkEndPoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkEndPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkEndPoint.Merge(m, src)
}
func (m *NetworkEndPoint) XXX_Size() int {
	return m.Size()
}
func (m *NetworkEndPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkEndPoint.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkEndPoint proto.InternalMessageInfo

type isNetworkEndPoint_Attrs interface {
	isNetworkEndPoint_Attrs()
	MarshalTo([]byte) (int, error)
	Size() int
}

type NetworkEndPoint_VlanAttrs struct {
	VlanAttrs *NetworkEndPoint_Vlan `protobuf:"bytes,3,opt,name=vlan_attrs,json=vlanAttrs,proto3,oneof" json:"vlan_attrs,omitempty"`
}
type NetworkEndPoint_VxlanAttrs struct {
	VxlanAttrs *NetworkEndPoint_Vxlan `protobuf:"bytes,4,opt,name=vxlan_attrs,json=vxlanAttrs,proto3,oneof" json:"vxlan_attrs,omitempty"`
}
type NetworkEndPoint_IPFabricAttrs struct {
	IPFabricAttrs *NetworkEndPoint_IPFabric `protobuf:"bytes,5,opt,name=ipfabric_attrs,json=ipfabricAttrs,proto3,oneof" json:"ipfabric_attrs,omitempty"`
}

func (*NetworkEndPoint_VlanAttrs) isNetworkEndPoint_Attrs()     {}
func (*NetworkEndPoint_VxlanAttrs) isNetworkEndPoint_Attrs()    {}
func (*NetworkEndPoint_IPFabricAttrs) isNetworkEndPoint_Attrs() {}

func (m *NetworkEndPoint) GetAttrs() isNetworkEndPoint_Attrs {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *NetworkEndPoint) GetLinkName() string {
	if m != nil {
		return m.LinkName
	}
	return ""
}

func (m *NetworkEndPoint) GetLinkIndex() uint32 {
	if m != nil {
		return m.LinkIndex
	}
	return 0
}

func (m *NetworkEndPoint) GetVlanAttrs() *NetworkEndPoint_Vlan {
	if x, ok := m.GetAttrs().(*NetworkEndPoint_VlanAttrs); ok {
		return x.VlanAttrs
	}
	return nil
}

func (m *NetworkEndPoint) GetVxlanAttrs() *NetworkEndPoint_Vxlan {
	if x, ok := m.GetAttrs().(*NetworkEndPoint_VxlanAttrs); ok {
		return x.VxlanAttrs
	}
	return nil
}

func (m *NetworkEndPoint) GetIPFabricAttrs() *NetworkEndPoint_IPFabric {
	if x, ok := m.GetAttrs().(*NetworkEndPoint_IPFabricAttrs); ok {
		return x.IPFabricAttrs
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*NetworkEndPoint) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*NetworkEndPoint_VlanAttrs)(nil),
		(*NetworkEndPoint_VxlanAttrs)(nil),
		(*NetworkEndPoint_IPFabricAttrs)(nil),
	}
}

type NetworkEndPoint_Port struct {
	LinkName             string   `protobuf:"bytes,1,opt,name=link_name,json=linkName,proto3" json:"link_name,omitempty"`
	LinkIndex            uint32   `protobuf:"varint,2,opt,name=link_index,json=linkIndex,proto3" json:"link_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkEndPoint_Port) Reset()         { *m = NetworkEndPoint_Port{} }
func (m *NetworkEndPoint_Port) String() string { return proto.CompactTextString(m) }
func (*NetworkEndPoint_Port) ProtoMessage()    {}
func (*NetworkEndPoint_Port) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{7, 0}
}
func (m *NetworkEndPoint_Port) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkEndPoint_Port) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkEndPoint_Port.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkEndPoint_Port) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkEndPoint_Port.Merge(m, src)
}
func (m *NetworkEndPoint_Port) XXX_Size() int {
	return m.Size()
}
func (m *NetworkEndPoint_Port) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkEndPoint_Port.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkEndPoint_Port proto.InternalMessageInfo

func (m *NetworkEndPoint_Port) GetLinkName() string {
	if m != nil {
		return m.LinkName
	}
	return ""
}

func (m *NetworkEndPoint_Port) GetLinkIndex() uint32 {
	if m != nil {
		return m.LinkIndex
	}
	return 0
}

type NetworkEndPoint_Vlan struct {
	VlanID               uint32                  `protobuf:"varint,1,opt,name=vlan_id,json=vlanId,proto3" json:"vlan_id,omitempty"`
	Ports                []*NetworkEndPoint_Port `protobuf:"bytes,3,rep,name=ports,proto3" json:"ports,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *NetworkEndPoint_Vlan) Reset()         { *m = NetworkEndPoint_Vlan{} }
func (m *NetworkEndPoint_Vlan) String() string { return proto.CompactTextString(m) }
func (*NetworkEndPoint_Vlan) ProtoMessage()    {}
func (*NetworkEndPoint_Vlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{7, 1}
}
func (m *NetworkEndPoint_Vlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkEndPoint_Vlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkEndPoint_Vlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkEndPoint_Vlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkEndPoint_Vlan.Merge(m, src)
}
func (m *NetworkEndPoint_Vlan) XXX_Size() int {
	return m.Size()
}
func (m *NetworkEndPoint_Vlan) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkEndPoint_Vlan.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkEndPoint_Vlan proto.InternalMessageInfo

func (m *NetworkEndPoint_Vlan) GetVlanID() uint32 {
	if m != nil {
		return m.VlanID
	}
	return 0
}

func (m *NetworkEndPoint_Vlan) GetPorts() []*NetworkEndPoint_Port {
	if m != nil {
		return m.Ports
	}
	return nil
}

type NetworkEndPoint_Vxlan struct {
	VNI                  uint32                  `protobuf:"varint,1,opt,name=vni,proto3" json:"vni,omitempty"`
	Ports                []*NetworkEndPoint_Port `protobuf:"bytes,3,rep,name=ports,proto3" json:"ports,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *NetworkEndPoint_Vxlan) Reset()         { *m = NetworkEndPoint_Vxlan{} }
func (m *NetworkEndPoint_Vxlan) String() string { return proto.CompactTextString(m) }
func (*NetworkEndPoint_Vxlan) ProtoMessage()    {}
func (*NetworkEndPoint_Vxlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{7, 2}
}
func (m *NetworkEndPoint_Vxlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkEndPoint_Vxlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkEndPoint_Vxlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkEndPoint_Vxlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkEndPoint_Vxlan.Merge(m, src)
}
func (m *NetworkEndPoint_Vxlan) XXX_Size() int {
	return m.Size()
}
func (m *NetworkEndPoint_Vxlan) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkEndPoint_Vxlan.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkEndPoint_Vxlan proto.InternalMessageInfo

func (m *NetworkEndPoint_Vxlan) GetVNI() uint32 {
	if m != nil {
		return m.VNI
	}
	return 0
}

func (m *NetworkEndPoint_Vxlan) GetPorts() []*NetworkEndPoint_Port {
	if m != nil {
		return m.Ports
	}
	return nil
}

type NetworkEndPoint_IPFabric struct {
	IPNets               []string `protobuf:"bytes,1,rep,name=ipnets,proto3" json:"ipnets,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkEndPoint_IPFabric) Reset()         { *m = NetworkEndPoint_IPFabric{} }
func (m *NetworkEndPoint_IPFabric) String() string { return proto.CompactTextString(m) }
func (*NetworkEndPoint_IPFabric) ProtoMessage()    {}
func (*NetworkEndPoint_IPFabric) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c0f90c600ad7e2e, []int{7, 3}
}
func (m *NetworkEndPoint_IPFabric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkEndPoint_IPFabric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkEndPoint_IPFabric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkEndPoint_IPFabric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkEndPoint_IPFabric.Merge(m, src)
}
func (m *NetworkEndPoint_IPFabric) XXX_Size() int {
	return m.Size()
}
func (m *NetworkEndPoint_IPFabric) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkEndPoint_IPFabric.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkEndPoint_IPFabric proto.InternalMessageInfo

func (m *NetworkEndPoint_IPFabric) GetIPNets() []string {
	if m != nil {
		return m.IPNets
	}
	return nil
}

func init() {
	proto.RegisterEnum("kvmrun.api.types.MachineState", MachineState_name, MachineState_value)
	proto.RegisterEnum("kvmrun.api.types.NetIfaceDriver", NetIfaceDriver_name, NetIfaceDriver_value)
	proto.RegisterEnum("kvmrun.api.types.NetIfaceLinkState", NetIfaceLinkState_name, NetIfaceLinkState_value)
	proto.RegisterEnum("kvmrun.api.types.DiskDriver", DiskDriver_name, DiskDriver_value)
	proto.RegisterEnum("kvmrun.api.types.CdromDriver", CdromDriver_name, CdromDriver_value)
	proto.RegisterEnum("kvmrun.api.types.InputDeviceType", InputDeviceType_name, InputDeviceType_value)
	proto.RegisterEnum("kvmrun.api.types.TaskInfo_TaskState", TaskInfo_TaskState_name, TaskInfo_TaskState_value)
	proto.RegisterType((*MachineOpts)(nil), "kvmrun.api.types.MachineOpts")
	proto.RegisterType((*MachineOpts_Firmware)(nil), "kvmrun.api.types.MachineOpts.Firmware")
	proto.RegisterType((*MachineOpts_Memory)(nil), "kvmrun.api.types.MachineOpts.Memory")
	proto.RegisterType((*MachineOpts_CPU)(nil), "kvmrun.api.types.MachineOpts.CPU")
	proto.RegisterType((*MachineOpts_HostPCI)(nil), "kvmrun.api.types.MachineOpts.HostPCI")
	proto.RegisterType((*MachineOpts_InputDevice)(nil), "kvmrun.api.types.MachineOpts.InputDevice")
	proto.RegisterType((*MachineOpts_Cdrom)(nil), "kvmrun.api.types.MachineOpts.Cdrom")
	proto.RegisterType((*MachineOpts_Disk)(nil), "kvmrun.api.types.MachineOpts.Disk")
	proto.RegisterType((*MachineOpts_NetIface)(nil), "kvmrun.api.types.MachineOpts.NetIface")
	proto.RegisterType((*MachineOpts_VirtioVSock)(nil), "kvmrun.api.types.MachineOpts.VirtioVSock")
	proto.RegisterType((*MachineOpts_CloudInit)(nil), "kvmrun.api.types.MachineOpts.CloudInit")
	proto.RegisterType((*MachineOpts_Kernel)(nil), "kvmrun.api.types.MachineOpts.Kernel")
	proto.RegisterType((*MachineOpts_BackendProxy)(nil), "kvmrun.api.types.MachineOpts.BackendProxy")
	proto.RegisterMapType((map[string]string)(nil), "kvmrun.api.types.MachineOpts.BackendProxy.EnvsEntry")
	proto.RegisterType((*Machine)(nil), "kvmrun.api.types.Machine")
	proto.RegisterType((*TaskInfo)(nil), "kvmrun.api.types.TaskInfo")
	proto.RegisterType((*TaskInfo_MigrationInfo)(nil), "kvmrun.api.types.TaskInfo.MigrationInfo")
	proto.RegisterMapType((map[string]*TaskInfo_MigrationInfo_Stat)(nil), "kvmrun.api.types.TaskInfo.MigrationInfo.DisksEntry")
	proto.RegisterType((*TaskInfo_MigrationInfo_Stat)(nil), "kvmrun.api.types.TaskInfo.MigrationInfo.Stat")
	proto.RegisterType((*MigrationOverrides)(nil), "kvmrun.api.types.MigrationOverrides")
	proto.RegisterMapType((map[string]string)(nil), "kvmrun.api.types.MigrationOverrides.DisksEntry")
	proto.RegisterType((*IncomingMachineRequisites)(nil), "kvmrun.api.types.IncomingMachineRequisites")
	proto.RegisterType((*VNCRequisites)(nil), "kvmrun.api.types.VNCRequisites")
	proto.RegisterType((*MachineEvent)(nil), "kvmrun.api.types.MachineEvent")
	proto.RegisterType((*MachineEvent_Timestamp)(nil), "kvmrun.api.types.MachineEvent.Timestamp")
	proto.RegisterType((*NetworkEndPoint)(nil), "kvmrun.api.types.NetworkEndPoint")
	proto.RegisterType((*NetworkEndPoint_Port)(nil), "kvmrun.api.types.NetworkEndPoint.Port")
	proto.RegisterType((*NetworkEndPoint_Vlan)(nil), "kvmrun.api.types.NetworkEndPoint.Vlan")
	proto.RegisterType((*NetworkEndPoint_Vxlan)(nil), "kvmrun.api.types.NetworkEndPoint.Vxlan")
	proto.RegisterType((*NetworkEndPoint_IPFabric)(nil), "kvmrun.api.types.NetworkEndPoint.IPFabric")
}

func init() { proto.RegisterFile("types/types.proto", fileDescriptor_2c0f90c600ad7e2e) }

var fileDescriptor_2c0f90c600ad7e2e = []byte{
	// 2146 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x58, 0x4b, 0x6f, 0x1b, 0xc9,
	0x11, 0x36, 0x1f, 0xc3, 0x47, 0x51, 0x94, 0xe9, 0x86, 0xe3, 0xd0, 0x4c, 0x6c, 0xc9, 0xf2, 0x66,
	0xa3, 0x08, 0x59, 0xca, 0x6b, 0xef, 0xc3, 0xbb, 0x6b, 0x20, 0x26, 0x39, 0xb4, 0x35, 0xb1, 0x44,
	0x11, 0x4d, 0x52, 0x46, 0x16, 0x08, 0x98, 0xd1, 0x4c, 0x53, 0x6a, 0x90, 0xf3, 0xf0, 0xcc, 0x90,
	0x12, 0x73, 0xc8, 0x35, 0xb7, 0x1c, 0x82, 0x20, 0xff, 0x21, 0xc8, 0x3d, 0xd7, 0x5c, 0x93, 0xdb,
	0xfe, 0x02, 0x61, 0xc1, 0x5f, 0xb2, 0xe8, 0xea, 0x1e, 0x92, 0xda, 0xa5, 0x25, 0x2d, 0xf6, 0x22,
	0x75, 0x55, 0xd7, 0xf7, 0x55, 0x75, 0x4d, 0x55, 0x4d, 0x0f, 0xe1, 0x4e, 0x34, 0xf5, 0x59, 0xb8,
	0x8b, 0x7f, 0xab, 0x7e, 0xe0, 0x45, 0x1e, 0x29, 0x0d, 0x27, 0x4e, 0x30, 0x76, 0xab, 0xa6, 0xcf,
	0xab, 0xa8, 0xaf, 0x7c, 0x74, 0xc2, 0xa3, 0xd3, 0xf1, 0x71, 0xd5, 0xf2, 0x9c, 0xdd, 0x13, 0xef,
	0xc4, 0xdb, 0x45, 0xc3, 0xe3, 0xf1, 0x00, 0x25, 0x14, 0x70, 0x25, 0x09, 0xb6, 0xbe, 0x29, 0x41,
	0xe1, 0xc0, 0xb4, 0x4e, 0xb9, 0xcb, 0x0e, 0xfd, 0x28, 0x24, 0x8f, 0x60, 0xcd, 0x91, 0x62, 0x5f,
	0xf0, 0x95, 0x13, 0x9b, 0x89, 0xed, 0x3c, 0x2d, 0x28, 0x5d, 0x77, 0xea, 0x33, 0x52, 0x87, 0xdc,
	0x80, 0x07, 0xce, 0x99, 0x19, 0xb0, 0x72, 0x72, 0x33, 0xb1, 0x5d, 0x78, 0xfa, 0x61, 0xf5, 0xfb,
	0x61, 0x54, 0x97, 0x38, 0xab, 0xaf, 0x94, 0x35, 0x9d, 0xe3, 0xc8, 0x0b, 0xc8, 0x38, 0xcc, 0xf1,
	0x82, 0x69, 0x39, 0x85, 0x0c, 0x1f, 0x5c, 0xcd, 0x70, 0x80, 0xb6, 0x54, 0x61, 0xc8, 0x0b, 0x48,
	0x59, 0xfe, 0xb8, 0x9c, 0x46, 0xe8, 0xa3, 0xab, 0xa1, 0x8d, 0x76, 0xaf, 0x9e, 0x9d, 0x5d, 0x6c,
	0xa4, 0x1a, 0xed, 0x1e, 0x15, 0x30, 0xd2, 0x81, 0xec, 0xa9, 0x17, 0x46, 0xbe, 0xc5, 0xcb, 0xda,
	0x66, 0x6a, 0xbb, 0xf0, 0xf4, 0x57, 0x57, 0x33, 0xec, 0x79, 0x61, 0xd4, 0x6e, 0x18, 0x75, 0x32,
	0xbb, 0xd8, 0x58, 0x57, 0x82, 0xce, 0x26, 0xdc, 0x62, 0x21, 0x8d, 0x99, 0x48, 0x0d, 0x32, 0xdc,
	0xf5, 0xc7, 0x51, 0x58, 0xce, 0x20, 0xe7, 0x6f, 0xae, 0xe6, 0x34, 0x84, 0xad, 0x24, 0xa1, 0x0a,
	0x48, 0xbe, 0x00, 0xcd, 0xb2, 0x03, 0xcf, 0x29, 0x67, 0x91, 0xe1, 0xf1, 0x35, 0xe7, 0x12, 0xa6,
	0x54, 0x22, 0xc8, 0x0b, 0xc8, 0x86, 0x91, 0x17, 0x98, 0x27, 0xac, 0x9c, 0x43, 0xf0, 0xd6, 0xd5,
	0x60, 0x9d, 0x87, 0x43, 0x1a, 0x43, 0xc8, 0x4b, 0xc8, 0xba, 0x2c, 0x3a, 0xf3, 0x82, 0x61, 0x39,
	0x8f, 0xe8, 0x6b, 0x9e, 0x67, 0x8b, 0x45, 0xc6, 0xc0, 0xb4, 0x18, 0x8d, 0x61, 0xe4, 0x6b, 0x58,
	0x9b, 0x84, 0x9e, 0x35, 0xec, 0xdb, 0x78, 0xa4, 0x32, 0xe0, 0x93, 0xb9, 0x26, 0x07, 0x47, 0x3c,
	0x88, 0xb8, 0x77, 0xd4, 0xf1, 0xac, 0x61, 0x7d, 0x6d, 0x76, 0xb1, 0x91, 0xc3, 0xa5, 0xce, 0x26,
	0xb4, 0x80, 0x64, 0x32, 0x3d, 0xe4, 0x8f, 0x70, 0xdb, 0x1a, 0x79, 0x63, 0x9b, 0xbb, 0x3c, 0xea,
	0xdb, 0x01, 0x9f, 0xb0, 0x72, 0x01, 0xe9, 0x7f, 0x7d, 0x4d, 0x82, 0x04, 0xc8, 0x70, 0x79, 0x54,
	0x2f, 0xcc, 0x2e, 0x36, 0xb2, 0x0d, 0x43, 0x17, 0x58, 0xba, 0x3e, 0x27, 0x43, 0x59, 0x54, 0xe2,
	0x90, 0x05, 0x2e, 0x1b, 0x95, 0xd7, 0x6e, 0x52, 0x89, 0x6f, 0xd0, 0x96, 0x2a, 0x0c, 0x79, 0x09,
	0x9a, 0x1f, 0x78, 0xe7, 0xd3, 0x72, 0x11, 0x13, 0xb7, 0x73, 0x35, 0xb8, 0x6e, 0x5a, 0x43, 0xe6,
	0xda, 0x6d, 0x81, 0xa0, 0x12, 0x58, 0xd9, 0x84, 0x5c, 0xdc, 0x1f, 0xe4, 0x2e, 0x68, 0xdc, 0x11,
	0x0f, 0x51, 0x76, 0x9d, 0x14, 0x2a, 0x9f, 0x41, 0x46, 0xd6, 0x3f, 0xb9, 0x07, 0x19, 0xd3, 0x8a,
	0xc6, 0xe6, 0x08, 0x0d, 0x52, 0x54, 0x49, 0x02, 0x17, 0x79, 0x91, 0x39, 0xc2, 0x76, 0x4c, 0x51,
	0x29, 0x54, 0xa6, 0x20, 0x6a, 0xfe, 0xc7, 0x81, 0x48, 0x19, 0xb2, 0x22, 0xf7, 0x2c, 0x0a, 0xb1,
	0x33, 0x35, 0x1a, 0x8b, 0xc2, 0xde, 0xf1, 0x6c, 0x36, 0xc2, 0xb6, 0xcb, 0x53, 0x29, 0x08, 0xed,
	0xbb, 0xb1, 0x17, 0x99, 0x65, 0x4d, 0xb2, 0xa0, 0x50, 0x89, 0x20, 0xab, 0x1a, 0x85, 0x10, 0x48,
	0x9b, 0xb6, 0x1d, 0xa8, 0x23, 0xe1, 0x9a, 0x7c, 0x00, 0x45, 0x67, 0x3c, 0x8a, 0xf8, 0x60, 0xec,
	0x5a, 0x11, 0xf7, 0x5c, 0x0c, 0x21, 0x47, 0x2f, 0x2b, 0xc9, 0x2e, 0x14, 0xfc, 0x80, 0x3b, 0x66,
	0x30, 0xed, 0x9f, 0xf8, 0x63, 0x0c, 0x27, 0x57, 0x5f, 0x9f, 0x5d, 0x6c, 0x40, 0x5b, 0xaa, 0x5f,
	0xb7, 0x7b, 0x14, 0x94, 0xc9, 0x6b, 0x7f, 0x5c, 0x79, 0x04, 0x85, 0xa5, 0xbe, 0x12, 0x9e, 0x97,
	0x46, 0x18, 0xae, 0x2b, 0x7f, 0x4d, 0x80, 0x86, 0x9d, 0x23, 0x76, 0x5d, 0xd3, 0x99, 0xef, 0x8a,
	0x35, 0x1e, 0x91, 0xd9, 0xdc, 0xc4, 0x78, 0xc4, 0x11, 0x85, 0x20, 0x12, 0x88, 0x65, 0x17, 0x60,
	0x08, 0x79, 0xaa, 0x24, 0xb2, 0x0d, 0xb9, 0x80, 0x99, 0xb6, 0xe7, 0x8e, 0xa6, 0x98, 0x93, 0x9c,
	0xac, 0x62, 0xca, 0x4c, 0xfb, 0xd0, 0x1d, 0x4d, 0xe9, 0x7c, 0x77, 0x9e, 0x03, 0x6d, 0x91, 0x83,
	0xca, 0x39, 0xa4, 0x45, 0x17, 0x8a, 0x3d, 0xdf, 0x8c, 0x4e, 0xe3, 0x38, 0xc4, 0x7a, 0xc9, 0x63,
	0xf2, 0x92, 0xc7, 0x9f, 0x43, 0x96, 0x7b, 0x7e, 0xd8, 0x0f, 0x6c, 0x0c, 0x25, 0x45, 0x33, 0x42,
	0xa4, 0xf6, 0x7c, 0xe3, 0x2c, 0xc0, 0x48, 0xd4, 0xc6, 0xdb, 0x60, 0xa5, 0xe7, 0x7f, 0x27, 0x20,
	0x17, 0xb7, 0xb0, 0x70, 0xc5, 0x07, 0x4b, 0x89, 0x50, 0xd2, 0x55, 0x21, 0x9c, 0x9e, 0xf5, 0x91,
	0x53, 0x65, 0xe3, 0xf4, 0xac, 0x26, 0x9e, 0x29, 0x81, 0x34, 0x1f, 0x8c, 0x7d, 0x55, 0x1d, 0xb8,
	0x96, 0xe4, 0xb6, 0x77, 0xe6, 0x2a, 0xff, 0x4a, 0x9a, 0x47, 0x95, 0x59, 0xaa, 0x89, 0x7b, 0x90,
	0x79, 0x37, 0x66, 0x63, 0x16, 0x96, 0xb3, 0x9b, 0x89, 0xed, 0x22, 0x55, 0x52, 0xc5, 0x82, 0xc2,
	0xd2, 0xa0, 0x40, 0xe8, 0x38, 0xf2, 0x30, 0xda, 0x1c, 0xc5, 0x35, 0xf9, 0x2d, 0x80, 0xe5, 0xb9,
	0x11, 0x3b, 0x8f, 0xfa, 0xdc, 0xc6, 0x78, 0x8b, 0xf5, 0xe2, 0xec, 0x62, 0x23, 0xdf, 0x90, 0x5a,
	0x43, 0xa7, 0x79, 0x65, 0x60, 0xd8, 0x73, 0xe7, 0xa9, 0xa5, 0x94, 0x6c, 0x40, 0x7e, 0x3e, 0x2e,
	0x56, 0x3d, 0x91, 0xca, 0x29, 0x64, 0x64, 0xe7, 0xaf, 0xee, 0x51, 0x3c, 0xa9, 0xcb, 0xa3, 0xc0,
	0x8e, 0xd3, 0x25, 0x25, 0xa1, 0x77, 0x3c, 0x9b, 0x87, 0x5e, 0x9c, 0x2d, 0x29, 0x89, 0x36, 0xb3,
	0x1c, 0x7b, 0xc4, 0x5d, 0xa6, 0x12, 0x16, 0x8b, 0x95, 0xff, 0x26, 0x60, 0x6d, 0x79, 0x4e, 0xac,
	0x2c, 0x10, 0x01, 0xf7, 0x1c, 0xc7, 0x74, 0x63, 0x7f, 0xb1, 0x48, 0xf6, 0x20, 0xcd, 0xdc, 0x89,
	0x68, 0x5e, 0x31, 0x8f, 0x3e, 0xb9, 0xf9, 0x3c, 0xaa, 0x36, 0xdd, 0x49, 0xd8, 0x74, 0xa3, 0x60,
	0x4a, 0x91, 0xa1, 0xf2, 0x39, 0xe4, 0xe7, 0x2a, 0x52, 0x82, 0xd4, 0x90, 0x4d, 0x55, 0x0c, 0x62,
	0x29, 0xf2, 0x30, 0x31, 0x47, 0x63, 0x16, 0xf7, 0x0a, 0x0a, 0x5f, 0x26, 0x9f, 0x27, 0xb6, 0xfe,
	0x9e, 0x84, 0xac, 0xf2, 0xb2, 0xb2, 0xcb, 0x3e, 0x85, 0x8c, 0xe5, 0xb9, 0x03, 0x7e, 0xa2, 0x6e,
	0x0f, 0x0f, 0xae, 0x0c, 0x92, 0x2a, 0x63, 0xf2, 0x39, 0x64, 0x83, 0xb1, 0x1b, 0x71, 0x87, 0xa9,
	0x3b, 0xc3, 0x35, 0xb8, 0xd8, 0x9a, 0x3c, 0x04, 0xf0, 0x59, 0x10, 0xf2, 0x30, 0x62, 0x6e, 0x24,
	0x3b, 0x95, 0x2e, 0x69, 0xc8, 0x27, 0xa0, 0x85, 0x91, 0x19, 0x31, 0x2c, 0xd2, 0xf5, 0xa7, 0x0f,
	0xdf, 0x4b, 0xdb, 0x11, 0x56, 0x54, 0x1a, 0x8b, 0x8c, 0xf8, 0xdc, 0xc6, 0x12, 0xd6, 0xa8, 0x58,
	0x92, 0x5f, 0x40, 0x7e, 0xc4, 0x07, 0xac, 0x8f, 0x21, 0x66, 0xb1, 0x0d, 0x73, 0x42, 0xd1, 0xe5,
	0x0e, 0xdb, 0xfa, 0x56, 0x83, 0x5c, 0xd7, 0x0c, 0x87, 0x86, 0x3b, 0xf0, 0x56, 0x64, 0xf3, 0xcb,
	0x38, 0x86, 0x24, 0xc6, 0xb0, 0xe2, 0x25, 0x14, 0x83, 0x71, 0x71, 0x29, 0x92, 0x07, 0x00, 0xb8,
	0xe8, 0xdb, 0x2c, 0xb4, 0x54, 0x9d, 0xe5, 0x51, 0xa3, 0xb3, 0xd0, 0x22, 0x15, 0xc8, 0xf9, 0x81,
	0x77, 0x12, 0xb0, 0x30, 0xc4, 0xc3, 0x6b, 0x74, 0x2e, 0x93, 0x3d, 0xc8, 0x3b, 0xfc, 0x24, 0x30,
	0x71, 0x08, 0xcb, 0x97, 0xf6, 0xf6, 0x15, 0xae, 0x0f, 0x62, 0x5b, 0x21, 0xed, 0xdd, 0xa2, 0x0b,
	0x70, 0xe5, 0x3f, 0x29, 0x28, 0x5e, 0xda, 0x16, 0x61, 0xd9, 0x61, 0xd4, 0x0f, 0x59, 0x20, 0xa6,
	0x88, 0x3c, 0x6b, 0xde, 0x0e, 0xa3, 0x0e, 0x2a, 0x48, 0x0d, 0xd2, 0xef, 0x98, 0x33, 0x56, 0x35,
	0xf0, 0xd1, 0x4d, 0xbd, 0x56, 0xc5, 0xd1, 0x29, 0x42, 0x89, 0x01, 0x9a, 0xcd, 0xc3, 0x61, 0x5c,
	0xec, 0xcf, 0x6e, 0xcc, 0x21, 0x06, 0xaf, 0xaa, 0x75, 0xc9, 0x50, 0xf9, 0x5b, 0x02, 0xd2, 0x82,
	0x79, 0xf1, 0x56, 0x14, 0x01, 0xa7, 0xe3, 0xb7, 0xe2, 0x2f, 0x21, 0x1f, 0x30, 0xc7, 0xe4, 0x2e,
	0x77, 0x65, 0xd5, 0xa6, 0xe9, 0x42, 0x41, 0x36, 0xa1, 0x10, 0x05, 0xa6, 0x1b, 0x0e, 0x58, 0x10,
	0x30, 0x39, 0x9a, 0xd3, 0x74, 0x59, 0x75, 0xe5, 0x33, 0xb8, 0x0b, 0x5a, 0xe8, 0x33, 0x66, 0x63,
	0xf9, 0x69, 0x54, 0x0a, 0x95, 0x13, 0x80, 0x45, 0x94, 0x2b, 0x0a, 0xa6, 0xb1, 0xdc, 0x7e, 0x3f,
	0x3a, 0x7f, 0x4b, 0xdd, 0xfa, 0x12, 0xf2, 0xf3, 0x8a, 0x22, 0x05, 0xc8, 0xf6, 0x5a, 0x6f, 0x5a,
	0x87, 0x6f, 0x5b, 0xa5, 0x5b, 0x42, 0xa0, 0xbd, 0x56, 0xcb, 0x68, 0xbd, 0x2e, 0x25, 0x48, 0x11,
	0xf2, 0x8d, 0xc3, 0x83, 0xf6, 0x7e, 0xb3, 0xdb, 0xd4, 0x4b, 0x49, 0x02, 0x90, 0x79, 0x55, 0x33,
	0xf6, 0x9b, 0x7a, 0x29, 0x55, 0xcf, 0x40, 0x5a, 0x54, 0xdb, 0xd6, 0xbf, 0x12, 0x40, 0xe6, 0xbe,
	0x0e, 0x27, 0x2c, 0x08, 0xb8, 0xcd, 0xc2, 0x95, 0x23, 0xa0, 0x19, 0x3f, 0xb9, 0x24, 0x3e, 0xb9,
	0xdd, 0x15, 0x2d, 0xf7, 0x03, 0xa2, 0x15, 0x4f, 0xed, 0xf9, 0x35, 0x49, 0x7a, 0xff, 0x8c, 0xfa,
	0x33, 0xdc, 0x37, 0x5c, 0xcb, 0x73, 0xb8, 0x7b, 0xa2, 0x9a, 0x9b, 0xb2, 0x77, 0x63, 0x1e, 0xf2,
	0x88, 0x85, 0xe4, 0x31, 0x14, 0xb9, 0xda, 0xec, 0xfb, 0x5e, 0x10, 0x21, 0xa5, 0x46, 0xd7, 0x62,
	0x65, 0xdb, 0x0b, 0x22, 0xf2, 0x21, 0xe4, 0xdc, 0x63, 0x5b, 0xee, 0x0b, 0x7a, 0x4d, 0x5e, 0x33,
	0x5b, 0x75, 0x5d, 0x6c, 0xd3, 0xac, 0x7b, 0x6c, 0xa3, 0x9d, 0x9a, 0x13, 0xa9, 0xf9, 0x9c, 0xd8,
	0xfa, 0x0b, 0x14, 0x8f, 0x5a, 0x8d, 0x25, 0x7f, 0xa2, 0x3a, 0xcc, 0x30, 0x3c, 0xf3, 0x02, 0x5b,
	0x45, 0x3f, 0x97, 0xc5, 0xa4, 0xb7, 0x79, 0xe8, 0x8f, 0xcc, 0xa9, 0xf4, 0x42, 0x63, 0x11, 0xdf,
	0x0b, 0xc2, 0xb9, 0x64, 0xc6, 0x35, 0x79, 0x0c, 0xd9, 0xb3, 0x50, 0xc6, 0x84, 0x65, 0x56, 0x87,
	0xd9, 0xc5, 0x46, 0xe6, 0x6d, 0x07, 0x43, 0xca, 0x9c, 0x85, 0xe2, 0xff, 0xd6, 0xff, 0x13, 0xb0,
	0xa6, 0x0e, 0xdd, 0x9c, 0x88, 0x01, 0xb8, 0xe2, 0xa2, 0x24, 0x74, 0xb6, 0x19, 0xc9, 0x9b, 0xd0,
	0x1a, 0xc5, 0x35, 0x79, 0x05, 0x79, 0x31, 0xdb, 0xc2, 0xc8, 0x74, 0x7c, 0x35, 0x83, 0xb7, 0xdf,
	0x3b, 0x2c, 0x91, 0xba, 0xda, 0x8d, 0xed, 0xe9, 0x02, 0x5a, 0x31, 0x20, 0x3f, 0xd7, 0xe3, 0x85,
	0x93, 0x59, 0x9e, 0x6b, 0x87, 0xaa, 0xe5, 0x62, 0x91, 0x6c, 0xc1, 0x9a, 0xc3, 0xad, 0xc0, 0x8b,
	0xb7, 0x65, 0xdf, 0x5d, 0xd2, 0x6d, 0xfd, 0x43, 0x83, 0xdb, 0x2d, 0xf9, 0x11, 0xd2, 0x74, 0xed,
	0xb6, 0xc7, 0xdd, 0x48, 0xce, 0x61, 0x77, 0xd8, 0x5f, 0xaa, 0xba, 0x9c, 0x50, 0xb4, 0x44, 0xe5,
	0x3d, 0x00, 0xc0, 0x4d, 0xee, 0xda, 0xec, 0x5c, 0xde, 0x15, 0x28, 0x9a, 0x1b, 0x42, 0x41, 0x5e,
	0x03, 0x4c, 0x46, 0xa6, 0xdb, 0x37, 0xa3, 0x28, 0x08, 0xd5, 0x19, 0x57, 0x7c, 0x0d, 0x7d, 0xcf,
	0x65, 0xf5, 0x68, 0x64, 0xba, 0x62, 0x1e, 0x0a, 0x6c, 0x4d, 0x40, 0xc9, 0xef, 0xa1, 0x30, 0x39,
	0x5f, 0x30, 0xa5, 0xdf, 0xf7, 0xc5, 0xf2, 0x03, 0xa6, 0x73, 0x49, 0x05, 0x88, 0x96, 0x5c, 0x03,
	0x58, 0xe7, 0xfe, 0xc0, 0x3c, 0x0e, 0xb8, 0xa5, 0xe8, 0x34, 0xa4, 0xdb, 0xb9, 0x9e, 0xce, 0x68,
	0xbf, 0x42, 0x5c, 0xfd, 0xce, 0xec, 0x62, 0xa3, 0x18, 0x4b, 0x48, 0xbb, 0x77, 0x8b, 0x16, 0x63,
	0x5a, 0x54, 0x54, 0xea, 0x90, 0xc6, 0x92, 0xfd, 0x09, 0x09, 0xac, 0x70, 0x48, 0x8b, 0x64, 0x88,
	0x4a, 0xc4, 0x44, 0x72, 0x59, 0xd2, 0x45, 0x59, 0x89, 0x62, 0xcb, 0xd0, 0x69, 0x46, 0x6c, 0x19,
	0x36, 0x79, 0x01, 0x9a, 0xa8, 0xd5, 0x78, 0x80, 0xdf, 0x20, 0xd1, 0x58, 0xc8, 0x12, 0x54, 0xf9,
	0x13, 0x68, 0x98, 0x2d, 0x72, 0x1f, 0x52, 0x13, 0x97, 0x2b, 0x3f, 0xf8, 0xad, 0x7f, 0xd4, 0x32,
	0xa8, 0xd0, 0xfd, 0x44, 0x0f, 0x55, 0xc8, 0xc5, 0x29, 0x23, 0x5b, 0x90, 0xe1, 0xbe, 0x2b, 0xbe,
	0x8b, 0x12, 0x9b, 0xa9, 0xed, 0xbc, 0x3c, 0x8f, 0xd1, 0x6e, 0x31, 0x71, 0x45, 0x91, 0x3b, 0xf5,
	0x2c, 0x68, 0xf8, 0x7c, 0x76, 0xfe, 0xb9, 0x68, 0xb1, 0xf9, 0x60, 0x6d, 0x1d, 0x76, 0xba, 0xb5,
	0x6e, 0xb3, 0x74, 0x8b, 0xac, 0x41, 0xae, 0xd3, 0xad, 0xd1, 0xae, 0x9c, 0xac, 0x4b, 0x63, 0x16,
	0xe7, 0x6a, 0xbb, 0xd6, 0xeb, 0x88, 0xb9, 0x8a, 0x66, 0x7b, 0xbd, 0xae, 0x2e, 0xa6, 0x71, 0x5a,
	0x48, 0x46, 0xab, 0xd6, 0xe8, 0x1a, 0x47, 0xcd, 0x92, 0x26, 0x40, 0x0d, 0x5a, 0xeb, 0xec, 0x35,
	0xf5, 0x52, 0x46, 0x6e, 0x35, 0x0e, 0x0f, 0x04, 0x45, 0x56, 0x4c, 0xea, 0x03, 0xe3, 0x35, 0xad,
	0x21, 0x7d, 0x4e, 0x6c, 0x4a, 0xb1, 0xa9, 0x97, 0xf2, 0x3b, 0x47, 0xb0, 0x1e, 0x5f, 0xfd, 0x75,
	0x79, 0xa1, 0x2f, 0xc3, 0xdd, 0x5e, 0x4b, 0x6f, 0xbe, 0x32, 0x5a, 0x4d, 0xbd, 0xdf, 0x6a, 0x76,
	0xfb, 0x3a, 0x35, 0x8e, 0x9a, 0xb4, 0x74, 0x8b, 0x10, 0x58, 0x3f, 0x32, 0x68, 0xd7, 0x38, 0x44,
	0x75, 0xbb, 0x61, 0xa8, 0x60, 0xbb, 0xfb, 0xcf, 0x3f, 0x7e, 0xf6, 0x45, 0x29, 0x49, 0xf2, 0xa0,
	0x35, 0x3f, 0x7e, 0xf2, 0xe4, 0x49, 0x29, 0xb5, 0xf3, 0x3b, 0xb8, 0x13, 0xf3, 0xee, 0x73, 0x57,
	0xbd, 0x4d, 0x2e, 0x51, 0xef, 0x1b, 0xad, 0x37, 0xfd, 0x38, 0x03, 0x19, 0x48, 0xf6, 0xda, 0xa5,
	0x04, 0xc9, 0x41, 0x1a, 0x8f, 0x97, 0xdc, 0xe9, 0xca, 0x51, 0xae, 0x82, 0xba, 0x0f, 0x3f, 0x5b,
	0x20, 0x75, 0xa3, 0xf3, 0x66, 0x55, 0x54, 0xf5, 0xfd, 0x37, 0x8b, 0xa8, 0x3a, 0x8d, 0x8e, 0xd1,
	0xdf, 0x53, 0xaf, 0x26, 0x43, 0x6f, 0x8a, 0x75, 0x6a, 0xa7, 0x0e, 0x05, 0xfc, 0xda, 0x53, 0xb4,
	0x15, 0xb8, 0xb7, 0xa0, 0x6d, 0xe8, 0xf4, 0xf0, 0x60, 0xc1, 0x1b, 0x73, 0x34, 0xf4, 0x52, 0x22,
	0xe6, 0x68, 0xe8, 0xa5, 0xe4, 0xce, 0x57, 0x70, 0x7b, 0xe9, 0xab, 0x12, 0x7f, 0x01, 0xbb, 0x74,
	0x30, 0xa3, 0xd5, 0xee, 0x75, 0xfb, 0xdd, 0x3f, 0xb4, 0xc5, 0xc1, 0xd6, 0x01, 0x7a, 0x9d, 0x7a,
	0xbf, 0x5b, 0xab, 0xef, 0x37, 0xbb, 0xa5, 0x44, 0xfd, 0xb3, 0xff, 0xcd, 0x1e, 0x26, 0xbe, 0x99,
	0x3d, 0x4c, 0x7c, 0x3b, 0x7b, 0x98, 0xf8, 0x7a, 0x7b, 0xe9, 0xb7, 0xb9, 0x27, 0xe7, 0x6c, 0xf0,
	0xe9, 0xb3, 0x5d, 0x59, 0x8f, 0xbb, 0xa6, 0xcf, 0xe5, 0xef, 0x7a, 0x5f, 0xe1, 0xdf, 0xe3, 0x0c,
	0xfe, 0x3a, 0xf7, 0xec, 0xbb, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf2, 0xa0, 0x4b, 0x38, 0xf3, 0x13,
	0x00, 0x00,
}

func (m *MachineOpts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MachineOpts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MachineOpts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Proxy) > 0 {
		for iNdEx := len(m.Proxy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Proxy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.Kernel != nil {
		{
			size, err := m.Kernel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.CIDrive != nil {
		{
			size, err := m.CIDrive.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.VSockDev != nil {
		{
			size, err := m.VSockDev.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Network) > 0 {
		for iNdEx := len(m.Network) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Network[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Storage) > 0 {
		for iNdEx := len(m.Storage) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Storage[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Cdrom) > 0 {
		for iNdEx := len(m.Cdrom) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cdrom[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Inputs) > 0 {
		for iNdEx := len(m.Inputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Inputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.HostPCIDevices) > 0 {
		for iNdEx := len(m.HostPCIDevices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HostPCIDevices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.CPU != nil {
		{
			size, err := m.CPU.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Memory != nil {
		{
			size, err := m.Memory.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Firmware != nil {
		{
			size, err := m.Firmware.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.MachineType) > 0 {
		i -= len(m.MachineType)
		copy(dAtA[i:], m.MachineType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MachineType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MachineOpts_Firmware) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MachineOpts_Firmware) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MachineOpts_Firmware) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MachineOpts_Memory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MachineOpts_Memory) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MachineOpts_Memory) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Total != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x10
	}
	if m.Actual != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Actual))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MachineOpts_CPU) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MachineOpts_CPU) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MachineOpts_CPU) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Quota != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Quota))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Model) > 0 {
		i -= len(m.Model)
		copy(dAtA[i:], m.Model)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Model)))
		i--
		dAtA[i] = 0x22
	}
	if m.Sockets != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Sockets))
		i--
		dAtA[i] = 0x18
	}
	if m.Total != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x10
	}
	if m.Actual != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Actual))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MachineOpts_HostPCI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MachineOpts_HostPCI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MachineOpts_HostPCI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PrimaryGPU {
		i--
		if m.PrimaryGPU {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Multifunction {
		i--
		if m.Multifunction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MachineOpts_InputDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MachineOpts_InputDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MachineOpts_InputDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MachineOpts_Cdrom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MachineOpts_Cdrom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MachineOpts_Cdrom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ReadOnly {
		i--
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Driver) > 0 {
		i -= len(m.Driver)
		copy(dAtA[i:], m.Driver)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Driver)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Media) > 0 {
		i -= len(m.Media)
		copy(dAtA[i:], m.Media)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Media)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MachineOpts_Disk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MachineOpts_Disk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MachineOpts_Disk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x2a
	}
	if m.IopsWr != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.IopsWr))
		i--
		dAtA[i] = 0x20
	}
	if m.IopsRd != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.IopsRd))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Driver) > 0 {
		i -= len(m.Driver)
		copy(dAtA[i:], m.Driver)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Driver)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MachineOpts_NetIface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MachineOpts_NetIface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MachineOpts_NetIface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Queues != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Queues))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Ifdown) > 0 {
		i -= len(m.Ifdown)
		copy(dAtA[i:], m.Ifdown)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Ifdown)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Ifup) > 0 {
		i -= len(m.Ifup)
		copy(dAtA[i:], m.Ifup)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Ifup)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.HwAddr) > 0 {
		i -= len(m.HwAddr)
		copy(dAtA[i:], m.HwAddr)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HwAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Driver) > 0 {
		i -= len(m.Driver)
		copy(dAtA[i:], m.Driver)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Driver)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Ifname) > 0 {
		i -= len(m.Ifname)
		copy(dAtA[i:], m.Ifname)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Ifname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MachineOpts_VirtioVSock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MachineOpts_VirtioVSock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MachineOpts_VirtioVSock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ContextID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ContextID))
		i--
		dAtA[i] = 0x10
	}
	if m.Auto {
		i--
		if m.Auto {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MachineOpts_CloudInit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MachineOpts_CloudInit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MachineOpts_CloudInit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MachineOpts_Kernel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MachineOpts_Kernel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MachineOpts_Kernel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cmdline) > 0 {
		i -= len(m.Cmdline)
		copy(dAtA[i:], m.Cmdline)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Cmdline)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Modiso) > 0 {
		i -= len(m.Modiso)
		copy(dAtA[i:], m.Modiso)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Modiso)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Initrd) > 0 {
		i -= len(m.Initrd)
		copy(dAtA[i:], m.Initrd)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Initrd)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MachineOpts_BackendProxy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MachineOpts_BackendProxy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MachineOpts_BackendProxy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Envs) > 0 {
		for k := range m.Envs {
			v := m.Envs[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Command) > 0 {
		i -= len(m.Command)
		copy(dAtA[i:], m.Command)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Command)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Machine) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Machine) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Machine) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LifeTime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LifeTime))
		i--
		dAtA[i] = 0x38
	}
	if m.Pid != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Pid))
		i--
		dAtA[i] = 0x30
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x28
	}
	if m.Persistent {
		i--
		if m.Persistent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Runtime != nil {
		{
			size, err := m.Runtime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Config != nil {
		{
			size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TaskInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stat != nil {
		{
			size := m.Stat.Size()
			i -= size
			if _, err := m.Stat.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Progress != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Progress))
		i--
		dAtA[i] = 0x20
	}
	if len(m.StateDesc) > 0 {
		i -= len(m.StateDesc)
		copy(dAtA[i:], m.StateDesc)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StateDesc)))
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TaskInfo_Migration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskInfo_Migration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Migration != nil {
		{
			size, err := m.Migration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *TaskInfo_MigrationInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskInfo_MigrationInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskInfo_MigrationInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Disks) > 0 {
		for k := range m.Disks {
			v := m.Disks[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTypes(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Qemu != nil {
		{
			size, err := m.Qemu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.DstServer) > 0 {
		i -= len(m.DstServer)
		copy(dAtA[i:], m.DstServer)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DstServer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TaskInfo_MigrationInfo_Stat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskInfo_MigrationInfo_Stat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskInfo_MigrationInfo_Stat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Speed != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Speed))
		i--
		dAtA[i] = 0x28
	}
	if m.Progress != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Progress))
		i--
		dAtA[i] = 0x20
	}
	if m.Transferred != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Transferred))
		i--
		dAtA[i] = 0x18
	}
	if m.Remaining != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Remaining))
		i--
		dAtA[i] = 0x10
	}
	if m.Total != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MigrationOverrides) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MigrationOverrides) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MigrationOverrides) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Disks) > 0 {
		for k := range m.Disks {
			v := m.Disks[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IncomingMachineRequisites) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncomingMachineRequisites) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IncomingMachineRequisites) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Pid != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Pid))
		i--
		dAtA[i] = 0x18
	}
	if m.NBDPort != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NBDPort))
		i--
		dAtA[i] = 0x10
	}
	if m.IncomingPort != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.IncomingPort))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VNCRequisites) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VNCRequisites) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VNCRequisites) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WSPort != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.WSPort))
		i--
		dAtA[i] = 0x20
	}
	if m.Port != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x18
	}
	if m.Display != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Display))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MachineEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MachineEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MachineEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MachineEvent_Timestamp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MachineEvent_Timestamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MachineEvent_Timestamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Microseconds != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Microseconds))
		i--
		dAtA[i] = 0x10
	}
	if m.Seconds != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Seconds))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NetworkEndPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkEndPoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkEndPoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Attrs != nil {
		{
			size := m.Attrs.Size()
			i -= size
			if _, err := m.Attrs.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.LinkIndex != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LinkIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LinkName) > 0 {
		i -= len(m.LinkName)
		copy(dAtA[i:], m.LinkName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LinkName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkEndPoint_VlanAttrs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkEndPoint_VlanAttrs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VlanAttrs != nil {
		{
			size, err := m.VlanAttrs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *NetworkEndPoint_VxlanAttrs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkEndPoint_VxlanAttrs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VxlanAttrs != nil {
		{
			size, err := m.VxlanAttrs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *NetworkEndPoint_IPFabricAttrs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkEndPoint_IPFabricAttrs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IPFabricAttrs != nil {
		{
			size, err := m.IPFabricAttrs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *NetworkEndPoint_Port) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkEndPoint_Port) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkEndPoint_Port) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LinkIndex != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LinkIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LinkName) > 0 {
		i -= len(m.LinkName)
		copy(dAtA[i:], m.LinkName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LinkName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkEndPoint_Vlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkEndPoint_Vlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkEndPoint_Vlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.VlanID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VlanID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NetworkEndPoint_Vxlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkEndPoint_Vxlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkEndPoint_Vxlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.VNI != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VNI))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NetworkEndPoint_IPFabric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkEndPoint_IPFabric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkEndPoint_IPFabric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IPNets) > 0 {
		for iNdEx := len(m.IPNets) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IPNets[iNdEx])
			copy(dAtA[i:], m.IPNets[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.IPNets[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MachineOpts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MachineType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Firmware != nil {
		l = m.Firmware.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Memory != nil {
		l = m.Memory.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CPU != nil {
		l = m.CPU.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.HostPCIDevices) > 0 {
		for _, e := range m.HostPCIDevices {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Inputs) > 0 {
		for _, e := range m.Inputs {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Cdrom) > 0 {
		for _, e := range m.Cdrom {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Storage) > 0 {
		for _, e := range m.Storage {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Network) > 0 {
		for _, e := range m.Network {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.VSockDev != nil {
		l = m.VSockDev.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CIDrive != nil {
		l = m.CIDrive.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Kernel != nil {
		l = m.Kernel.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Proxy) > 0 {
		for _, e := range m.Proxy {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MachineOpts_Firmware) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MachineOpts_Memory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Actual != 0 {
		n += 1 + sovTypes(uint64(m.Actual))
	}
	if m.Total != 0 {
		n += 1 + sovTypes(uint64(m.Total))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MachineOpts_CPU) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Actual != 0 {
		n += 1 + sovTypes(uint64(m.Actual))
	}
	if m.Total != 0 {
		n += 1 + sovTypes(uint64(m.Total))
	}
	if m.Sockets != 0 {
		n += 1 + sovTypes(uint64(m.Sockets))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Quota != 0 {
		n += 1 + sovTypes(uint64(m.Quota))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MachineOpts_HostPCI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Multifunction {
		n += 2
	}
	if m.PrimaryGPU {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MachineOpts_InputDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MachineOpts_Cdrom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Media)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Driver)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ReadOnly {
		n += 2
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MachineOpts_Disk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Driver)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IopsRd != 0 {
		n += 1 + sovTypes(uint64(m.IopsRd))
	}
	if m.IopsWr != 0 {
		n += 1 + sovTypes(uint64(m.IopsWr))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MachineOpts_NetIface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ifname)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Driver)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.HwAddr)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Ifup)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Ifdown)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Queues != 0 {
		n += 1 + sovTypes(uint64(m.Queues))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MachineOpts_VirtioVSock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Auto {
		n += 2
	}
	if m.ContextID != 0 {
		n += 1 + sovTypes(uint64(m.ContextID))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MachineOpts_CloudInit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MachineOpts_Kernel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Initrd)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Modiso)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Cmdline)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MachineOpts_BackendProxy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Command)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Envs) > 0 {
		for k, v := range m.Envs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Machine) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Runtime != nil {
		l = m.Runtime.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Persistent {
		n += 2
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	if m.Pid != 0 {
		n += 1 + sovTypes(uint64(m.Pid))
	}
	if m.LifeTime != 0 {
		n += 1 + sovTypes(uint64(m.LifeTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TaskInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	l = len(m.StateDesc)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Progress != 0 {
		n += 1 + sovTypes(uint64(m.Progress))
	}
	if m.Stat != nil {
		n += m.Stat.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TaskInfo_Migration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Migration != nil {
		l = m.Migration.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TaskInfo_MigrationInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DstServer)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Qemu != nil {
		l = m.Qemu.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Disks) > 0 {
		for k, v := range m.Disks {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TaskInfo_MigrationInfo_Stat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovTypes(uint64(m.Total))
	}
	if m.Remaining != 0 {
		n += 1 + sovTypes(uint64(m.Remaining))
	}
	if m.Transferred != 0 {
		n += 1 + sovTypes(uint64(m.Transferred))
	}
	if m.Progress != 0 {
		n += 1 + sovTypes(uint64(m.Progress))
	}
	if m.Speed != 0 {
		n += 1 + sovTypes(uint64(m.Speed))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MigrationOverrides) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Disks) > 0 {
		for k, v := range m.Disks {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IncomingMachineRequisites) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IncomingPort != 0 {
		n += 1 + sovTypes(uint64(m.IncomingPort))
	}
	if m.NBDPort != 0 {
		n += 1 + sovTypes(uint64(m.NBDPort))
	}
	if m.Pid != 0 {
		n += 1 + sovTypes(uint64(m.Pid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VNCRequisites) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Display != 0 {
		n += 1 + sovTypes(uint64(m.Display))
	}
	if m.Port != 0 {
		n += 1 + sovTypes(uint64(m.Port))
	}
	if m.WSPort != 0 {
		n += 1 + sovTypes(uint64(m.WSPort))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MachineEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MachineEvent_Timestamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seconds != 0 {
		n += 1 + sovTypes(uint64(m.Seconds))
	}
	if m.Microseconds != 0 {
		n += 1 + sovTypes(uint64(m.Microseconds))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkEndPoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LinkName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LinkIndex != 0 {
		n += 1 + sovTypes(uint64(m.LinkIndex))
	}
	if m.Attrs != nil {
		n += m.Attrs.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkEndPoint_VlanAttrs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VlanAttrs != nil {
		l = m.VlanAttrs.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkEndPoint_VxlanAttrs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VxlanAttrs != nil {
		l = m.VxlanAttrs.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkEndPoint_IPFabricAttrs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IPFabricAttrs != nil {
		l = m.IPFabricAttrs.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkEndPoint_Port) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LinkName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LinkIndex != 0 {
		n += 1 + sovTypes(uint64(m.LinkIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkEndPoint_Vlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VlanID != 0 {
		n += 1 + sovTypes(uint64(m.VlanID))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkEndPoint_Vxlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VNI != 0 {
		n += 1 + sovTypes(uint64(m.VNI))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkEndPoint_IPFabric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IPNets) > 0 {
		for _, s := range m.IPNets {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MachineOpts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MachineOpts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MachineOpts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MachineType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MachineType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Firmware", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Firmware == nil {
				m.Firmware = &MachineOpts_Firmware{}
			}
			if err := m.Firmware.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Memory == nil {
				m.Memory = &MachineOpts_Memory{}
			}
			if err := m.Memory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPU", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CPU == nil {
				m.CPU = &MachineOpts_CPU{}
			}
			if err := m.CPU.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPCIDevices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPCIDevices = append(m.HostPCIDevices, &MachineOpts_HostPCI{})
			if err := m.HostPCIDevices[len(m.HostPCIDevices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inputs = append(m.Inputs, &MachineOpts_InputDevice{})
			if err := m.Inputs[len(m.Inputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cdrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cdrom = append(m.Cdrom, &MachineOpts_Cdrom{})
			if err := m.Cdrom[len(m.Cdrom)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Storage = append(m.Storage, &MachineOpts_Disk{})
			if err := m.Storage[len(m.Storage)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = append(m.Network, &MachineOpts_NetIface{})
			if err := m.Network[len(m.Network)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VSockDev", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VSockDev == nil {
				m.VSockDev = &MachineOpts_VirtioVSock{}
			}
			if err := m.VSockDev.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CIDrive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CIDrive == nil {
				m.CIDrive = &MachineOpts_CloudInit{}
			}
			if err := m.CIDrive.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kernel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kernel == nil {
				m.Kernel = &MachineOpts_Kernel{}
			}
			if err := m.Kernel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proxy = append(m.Proxy, &MachineOpts_BackendProxy{})
			if err := m.Proxy[len(m.Proxy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MachineOpts_Firmware) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Firmware: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Firmware: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MachineOpts_Memory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Memory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Memory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actual", wireType)
			}
			m.Actual = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Actual |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MachineOpts_CPU) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPU: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPU: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actual", wireType)
			}
			m.Actual = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Actual |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sockets", wireType)
			}
			m.Sockets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sockets |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quota", wireType)
			}
			m.Quota = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quota |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MachineOpts_HostPCI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostPCI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostPCI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multifunction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Multifunction = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryGPU", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrimaryGPU = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MachineOpts_InputDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MachineOpts_Cdrom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cdrom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cdrom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Media = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Driver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MachineOpts_Disk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Disk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Disk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Driver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IopsRd", wireType)
			}
			m.IopsRd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IopsRd |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IopsWr", wireType)
			}
			m.IopsWr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IopsWr |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MachineOpts_NetIface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetIface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetIface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ifname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ifname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Driver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HwAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ifup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ifup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ifdown", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ifdown = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queues", wireType)
			}
			m.Queues = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Queues |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MachineOpts_VirtioVSock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtioVSock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtioVSock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auto", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Auto = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContextID", wireType)
			}
			m.ContextID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContextID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MachineOpts_CloudInit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudInit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudInit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MachineOpts_Kernel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Kernel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Kernel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Initrd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Initrd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modiso", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Modiso = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmdline", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cmdline = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MachineOpts_BackendProxy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackendProxy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackendProxy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Envs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Envs == nil {
				m.Envs = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Envs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Machine) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Machine: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Machine: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &MachineOpts{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Runtime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Runtime == nil {
				m.Runtime = &MachineOpts{}
			}
			if err := m.Runtime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Persistent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Persistent = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= MachineState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LifeTime", wireType)
			}
			m.LifeTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LifeTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= TaskInfo_TaskState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			m.Progress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Progress |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Migration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TaskInfo_MigrationInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Stat = &TaskInfo_Migration{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskInfo_MigrationInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MigrationInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MigrationInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstServer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstServer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qemu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Qemu == nil {
				m.Qemu = &TaskInfo_MigrationInfo_Stat{}
			}
			if err := m.Qemu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Disks == nil {
				m.Disks = make(map[string]*TaskInfo_MigrationInfo_Stat)
			}
			var mapkey string
			var mapvalue *TaskInfo_MigrationInfo_Stat
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TaskInfo_MigrationInfo_Stat{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Disks[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskInfo_MigrationInfo_Stat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remaining", wireType)
			}
			m.Remaining = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Remaining |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transferred", wireType)
			}
			m.Transferred = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Transferred |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			m.Progress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Progress |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			m.Speed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Speed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MigrationOverrides) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MigrationOverrides: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MigrationOverrides: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Disks == nil {
				m.Disks = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Disks[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncomingMachineRequisites) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncomingMachineRequisites: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncomingMachineRequisites: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncomingPort", wireType)
			}
			m.IncomingPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IncomingPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NBDPort", wireType)
			}
			m.NBDPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NBDPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VNCRequisites) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VNCRequisites: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VNCRequisites: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Display", wireType)
			}
			m.Display = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Display |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WSPort", wireType)
			}
			m.WSPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WSPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MachineEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MachineEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MachineEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &MachineEvent_Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MachineEvent_Timestamp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timestamp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timestamp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seconds", wireType)
			}
			m.Seconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seconds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Microseconds", wireType)
			}
			m.Microseconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Microseconds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkEndPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkEndPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkEndPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkIndex", wireType)
			}
			m.LinkIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanAttrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NetworkEndPoint_Vlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Attrs = &NetworkEndPoint_VlanAttrs{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VxlanAttrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NetworkEndPoint_Vxlan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Attrs = &NetworkEndPoint_VxlanAttrs{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPFabricAttrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NetworkEndPoint_IPFabric{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Attrs = &NetworkEndPoint_IPFabricAttrs{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkEndPoint_Port) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Port: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Port: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkIndex", wireType)
			}
			m.LinkIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkEndPoint_Vlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanID", wireType)
			}
			m.VlanID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VlanID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &NetworkEndPoint_Port{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkEndPoint_Vxlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vxlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vxlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VNI", wireType)
			}
			m.VNI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VNI |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &NetworkEndPoint_Port{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkEndPoint_IPFabric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPFabric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPFabric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPNets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPNets = append(m.IPNets, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
