// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: services/machines/v1/machines.proto

package machines

import (
	context "context"
	fmt "fmt"
	types "github.com/0xef53/kvmrun/api/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CreateMachineRequest struct {
	Name                 string             `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Options              *types.MachineOpts `protobuf:"bytes,2,opt,name=options,proto3" json:"options,omitempty"`
	Persistent           bool               `protobuf:"varint,3,opt,name=persistent,proto3" json:"persistent,omitempty"`
	ExtraFiles           map[string][]byte  `protobuf:"bytes,4,rep,name=extra_files,json=extraFiles,proto3" json:"extra_files,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *CreateMachineRequest) Reset()         { *m = CreateMachineRequest{} }
func (m *CreateMachineRequest) String() string { return proto.CompactTextString(m) }
func (*CreateMachineRequest) ProtoMessage()    {}
func (*CreateMachineRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{0}
}
func (m *CreateMachineRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateMachineRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateMachineRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateMachineRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateMachineRequest.Merge(m, src)
}
func (m *CreateMachineRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateMachineRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateMachineRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateMachineRequest proto.InternalMessageInfo

func (m *CreateMachineRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateMachineRequest) GetOptions() *types.MachineOpts {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *CreateMachineRequest) GetPersistent() bool {
	if m != nil {
		return m.Persistent
	}
	return false
}

func (m *CreateMachineRequest) GetExtraFiles() map[string][]byte {
	if m != nil {
		return m.ExtraFiles
	}
	return nil
}

type CreateMachineResponse struct {
	Machine              *types.Machine `protobuf:"bytes,1,opt,name=machine,proto3" json:"machine,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *CreateMachineResponse) Reset()         { *m = CreateMachineResponse{} }
func (m *CreateMachineResponse) String() string { return proto.CompactTextString(m) }
func (*CreateMachineResponse) ProtoMessage()    {}
func (*CreateMachineResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{1}
}
func (m *CreateMachineResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateMachineResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateMachineResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateMachineResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateMachineResponse.Merge(m, src)
}
func (m *CreateMachineResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateMachineResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateMachineResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateMachineResponse proto.InternalMessageInfo

func (m *CreateMachineResponse) GetMachine() *types.Machine {
	if m != nil {
		return m.Machine
	}
	return nil
}

type DeleteMachineRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Force                bool     `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteMachineRequest) Reset()         { *m = DeleteMachineRequest{} }
func (m *DeleteMachineRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteMachineRequest) ProtoMessage()    {}
func (*DeleteMachineRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{2}
}
func (m *DeleteMachineRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteMachineRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteMachineRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteMachineRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteMachineRequest.Merge(m, src)
}
func (m *DeleteMachineRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteMachineRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteMachineRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteMachineRequest proto.InternalMessageInfo

func (m *DeleteMachineRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DeleteMachineRequest) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

type DeleteMachineResponse struct {
	Machine              *types.Machine `protobuf:"bytes,1,opt,name=machine,proto3" json:"machine,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *DeleteMachineResponse) Reset()         { *m = DeleteMachineResponse{} }
func (m *DeleteMachineResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteMachineResponse) ProtoMessage()    {}
func (*DeleteMachineResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{3}
}
func (m *DeleteMachineResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteMachineResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteMachineResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteMachineResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteMachineResponse.Merge(m, src)
}
func (m *DeleteMachineResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteMachineResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteMachineResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteMachineResponse proto.InternalMessageInfo

func (m *DeleteMachineResponse) GetMachine() *types.Machine {
	if m != nil {
		return m.Machine
	}
	return nil
}

type GetMachineRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetMachineRequest) Reset()         { *m = GetMachineRequest{} }
func (m *GetMachineRequest) String() string { return proto.CompactTextString(m) }
func (*GetMachineRequest) ProtoMessage()    {}
func (*GetMachineRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{4}
}
func (m *GetMachineRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMachineRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMachineRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMachineRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMachineRequest.Merge(m, src)
}
func (m *GetMachineRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetMachineRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMachineRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetMachineRequest proto.InternalMessageInfo

func (m *GetMachineRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type GetMachineResponse struct {
	Machine              *types.Machine `protobuf:"bytes,1,opt,name=machine,proto3" json:"machine,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetMachineResponse) Reset()         { *m = GetMachineResponse{} }
func (m *GetMachineResponse) String() string { return proto.CompactTextString(m) }
func (*GetMachineResponse) ProtoMessage()    {}
func (*GetMachineResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{5}
}
func (m *GetMachineResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMachineResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMachineResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMachineResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMachineResponse.Merge(m, src)
}
func (m *GetMachineResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetMachineResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMachineResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetMachineResponse proto.InternalMessageInfo

func (m *GetMachineResponse) GetMachine() *types.Machine {
	if m != nil {
		return m.Machine
	}
	return nil
}

type GetEventsResponse struct {
	Events               []*types.MachineEvent `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *GetEventsResponse) Reset()         { *m = GetEventsResponse{} }
func (m *GetEventsResponse) String() string { return proto.CompactTextString(m) }
func (*GetEventsResponse) ProtoMessage()    {}
func (*GetEventsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{6}
}
func (m *GetEventsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetEventsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetEventsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetEventsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetEventsResponse.Merge(m, src)
}
func (m *GetEventsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetEventsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetEventsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetEventsResponse proto.InternalMessageInfo

func (m *GetEventsResponse) GetEvents() []*types.MachineEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

type StartMachineRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	WaitInterval         int32    `protobuf:"varint,2,opt,name=wait_interval,json=waitInterval,proto3" json:"wait_interval,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StartMachineRequest) Reset()         { *m = StartMachineRequest{} }
func (m *StartMachineRequest) String() string { return proto.CompactTextString(m) }
func (*StartMachineRequest) ProtoMessage()    {}
func (*StartMachineRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{7}
}
func (m *StartMachineRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartMachineRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartMachineRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartMachineRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartMachineRequest.Merge(m, src)
}
func (m *StartMachineRequest) XXX_Size() int {
	return m.Size()
}
func (m *StartMachineRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StartMachineRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StartMachineRequest proto.InternalMessageInfo

func (m *StartMachineRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *StartMachineRequest) GetWaitInterval() int32 {
	if m != nil {
		return m.WaitInterval
	}
	return 0
}

type StopMachineRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Wait                 bool     `protobuf:"varint,2,opt,name=wait,proto3" json:"wait,omitempty"`
	Force                bool     `protobuf:"varint,3,opt,name=force,proto3" json:"force,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StopMachineRequest) Reset()         { *m = StopMachineRequest{} }
func (m *StopMachineRequest) String() string { return proto.CompactTextString(m) }
func (*StopMachineRequest) ProtoMessage()    {}
func (*StopMachineRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{8}
}
func (m *StopMachineRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StopMachineRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StopMachineRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StopMachineRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StopMachineRequest.Merge(m, src)
}
func (m *StopMachineRequest) XXX_Size() int {
	return m.Size()
}
func (m *StopMachineRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StopMachineRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StopMachineRequest proto.InternalMessageInfo

func (m *StopMachineRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *StopMachineRequest) GetWait() bool {
	if m != nil {
		return m.Wait
	}
	return false
}

func (m *StopMachineRequest) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

type RestartMachineRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Wait                 bool     `protobuf:"varint,2,opt,name=wait,proto3" json:"wait,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RestartMachineRequest) Reset()         { *m = RestartMachineRequest{} }
func (m *RestartMachineRequest) String() string { return proto.CompactTextString(m) }
func (*RestartMachineRequest) ProtoMessage()    {}
func (*RestartMachineRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{9}
}
func (m *RestartMachineRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestartMachineRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RestartMachineRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RestartMachineRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestartMachineRequest.Merge(m, src)
}
func (m *RestartMachineRequest) XXX_Size() int {
	return m.Size()
}
func (m *RestartMachineRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RestartMachineRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RestartMachineRequest proto.InternalMessageInfo

func (m *RestartMachineRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RestartMachineRequest) GetWait() bool {
	if m != nil {
		return m.Wait
	}
	return false
}

type ListMachinesRequest struct {
	Names                []string `protobuf:"bytes,1,rep,name=names,proto3" json:"names,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListMachinesRequest) Reset()         { *m = ListMachinesRequest{} }
func (m *ListMachinesRequest) String() string { return proto.CompactTextString(m) }
func (*ListMachinesRequest) ProtoMessage()    {}
func (*ListMachinesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{10}
}
func (m *ListMachinesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListMachinesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListMachinesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListMachinesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListMachinesRequest.Merge(m, src)
}
func (m *ListMachinesRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListMachinesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListMachinesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListMachinesRequest proto.InternalMessageInfo

func (m *ListMachinesRequest) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

type ListMachinesResponse struct {
	Machines             []*types.Machine `protobuf:"bytes,1,rep,name=machines,proto3" json:"machines,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ListMachinesResponse) Reset()         { *m = ListMachinesResponse{} }
func (m *ListMachinesResponse) String() string { return proto.CompactTextString(m) }
func (*ListMachinesResponse) ProtoMessage()    {}
func (*ListMachinesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{11}
}
func (m *ListMachinesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListMachinesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListMachinesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListMachinesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListMachinesResponse.Merge(m, src)
}
func (m *ListMachinesResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListMachinesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListMachinesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListMachinesResponse proto.InternalMessageInfo

func (m *ListMachinesResponse) GetMachines() []*types.Machine {
	if m != nil {
		return m.Machines
	}
	return nil
}

type ListNamesResponse struct {
	Machines             []string `protobuf:"bytes,1,rep,name=machines,proto3" json:"machines,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListNamesResponse) Reset()         { *m = ListNamesResponse{} }
func (m *ListNamesResponse) String() string { return proto.CompactTextString(m) }
func (*ListNamesResponse) ProtoMessage()    {}
func (*ListNamesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{12}
}
func (m *ListNamesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListNamesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListNamesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListNamesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListNamesResponse.Merge(m, src)
}
func (m *ListNamesResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListNamesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListNamesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListNamesResponse proto.InternalMessageInfo

func (m *ListNamesResponse) GetMachines() []string {
	if m != nil {
		return m.Machines
	}
	return nil
}

type SetMemLimitsRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Actual               int64    `protobuf:"varint,2,opt,name=actual,proto3" json:"actual,omitempty"`
	Total                int64    `protobuf:"varint,3,opt,name=total,proto3" json:"total,omitempty"`
	Live                 bool     `protobuf:"varint,100,opt,name=live,proto3" json:"live,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetMemLimitsRequest) Reset()         { *m = SetMemLimitsRequest{} }
func (m *SetMemLimitsRequest) String() string { return proto.CompactTextString(m) }
func (*SetMemLimitsRequest) ProtoMessage()    {}
func (*SetMemLimitsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{13}
}
func (m *SetMemLimitsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetMemLimitsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetMemLimitsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetMemLimitsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetMemLimitsRequest.Merge(m, src)
}
func (m *SetMemLimitsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetMemLimitsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetMemLimitsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetMemLimitsRequest proto.InternalMessageInfo

func (m *SetMemLimitsRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SetMemLimitsRequest) GetActual() int64 {
	if m != nil {
		return m.Actual
	}
	return 0
}

func (m *SetMemLimitsRequest) GetTotal() int64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *SetMemLimitsRequest) GetLive() bool {
	if m != nil {
		return m.Live
	}
	return false
}

type SetCPULimitsRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Actual               int64    `protobuf:"varint,2,opt,name=actual,proto3" json:"actual,omitempty"`
	Total                int64    `protobuf:"varint,3,opt,name=total,proto3" json:"total,omitempty"`
	Live                 bool     `protobuf:"varint,100,opt,name=live,proto3" json:"live,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetCPULimitsRequest) Reset()         { *m = SetCPULimitsRequest{} }
func (m *SetCPULimitsRequest) String() string { return proto.CompactTextString(m) }
func (*SetCPULimitsRequest) ProtoMessage()    {}
func (*SetCPULimitsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{14}
}
func (m *SetCPULimitsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetCPULimitsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetCPULimitsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetCPULimitsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetCPULimitsRequest.Merge(m, src)
}
func (m *SetCPULimitsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetCPULimitsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetCPULimitsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetCPULimitsRequest proto.InternalMessageInfo

func (m *SetCPULimitsRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SetCPULimitsRequest) GetActual() int64 {
	if m != nil {
		return m.Actual
	}
	return 0
}

func (m *SetCPULimitsRequest) GetTotal() int64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *SetCPULimitsRequest) GetLive() bool {
	if m != nil {
		return m.Live
	}
	return false
}

type SetCPUSocketsRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Sockets              int32    `protobuf:"varint,2,opt,name=sockets,proto3" json:"sockets,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetCPUSocketsRequest) Reset()         { *m = SetCPUSocketsRequest{} }
func (m *SetCPUSocketsRequest) String() string { return proto.CompactTextString(m) }
func (*SetCPUSocketsRequest) ProtoMessage()    {}
func (*SetCPUSocketsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{15}
}
func (m *SetCPUSocketsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetCPUSocketsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetCPUSocketsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetCPUSocketsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetCPUSocketsRequest.Merge(m, src)
}
func (m *SetCPUSocketsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetCPUSocketsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetCPUSocketsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetCPUSocketsRequest proto.InternalMessageInfo

func (m *SetCPUSocketsRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SetCPUSocketsRequest) GetSockets() int32 {
	if m != nil {
		return m.Sockets
	}
	return 0
}

type SetCPUQuotaRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Quota                int32    `protobuf:"varint,2,opt,name=quota,proto3" json:"quota,omitempty"`
	Live                 bool     `protobuf:"varint,100,opt,name=live,proto3" json:"live,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetCPUQuotaRequest) Reset()         { *m = SetCPUQuotaRequest{} }
func (m *SetCPUQuotaRequest) String() string { return proto.CompactTextString(m) }
func (*SetCPUQuotaRequest) ProtoMessage()    {}
func (*SetCPUQuotaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{16}
}
func (m *SetCPUQuotaRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetCPUQuotaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetCPUQuotaRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetCPUQuotaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetCPUQuotaRequest.Merge(m, src)
}
func (m *SetCPUQuotaRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetCPUQuotaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetCPUQuotaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetCPUQuotaRequest proto.InternalMessageInfo

func (m *SetCPUQuotaRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SetCPUQuotaRequest) GetQuota() int32 {
	if m != nil {
		return m.Quota
	}
	return 0
}

func (m *SetCPUQuotaRequest) GetLive() bool {
	if m != nil {
		return m.Live
	}
	return false
}

type SetCPUModelRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Model                string   `protobuf:"bytes,2,opt,name=model,proto3" json:"model,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetCPUModelRequest) Reset()         { *m = SetCPUModelRequest{} }
func (m *SetCPUModelRequest) String() string { return proto.CompactTextString(m) }
func (*SetCPUModelRequest) ProtoMessage()    {}
func (*SetCPUModelRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{17}
}
func (m *SetCPUModelRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetCPUModelRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetCPUModelRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetCPUModelRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetCPUModelRequest.Merge(m, src)
}
func (m *SetCPUModelRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetCPUModelRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetCPUModelRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetCPUModelRequest proto.InternalMessageInfo

func (m *SetCPUModelRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SetCPUModelRequest) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

type ActivateVNCRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Password             string   `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ActivateVNCRequest) Reset()         { *m = ActivateVNCRequest{} }
func (m *ActivateVNCRequest) String() string { return proto.CompactTextString(m) }
func (*ActivateVNCRequest) ProtoMessage()    {}
func (*ActivateVNCRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{18}
}
func (m *ActivateVNCRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActivateVNCRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActivateVNCRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActivateVNCRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActivateVNCRequest.Merge(m, src)
}
func (m *ActivateVNCRequest) XXX_Size() int {
	return m.Size()
}
func (m *ActivateVNCRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ActivateVNCRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ActivateVNCRequest proto.InternalMessageInfo

func (m *ActivateVNCRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ActivateVNCRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type ActivateVNCResponse struct {
	Requisites           *types.VNCRequisites `protobuf:"bytes,1,opt,name=requisites,proto3" json:"requisites,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ActivateVNCResponse) Reset()         { *m = ActivateVNCResponse{} }
func (m *ActivateVNCResponse) String() string { return proto.CompactTextString(m) }
func (*ActivateVNCResponse) ProtoMessage()    {}
func (*ActivateVNCResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{19}
}
func (m *ActivateVNCResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActivateVNCResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActivateVNCResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActivateVNCResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActivateVNCResponse.Merge(m, src)
}
func (m *ActivateVNCResponse) XXX_Size() int {
	return m.Size()
}
func (m *ActivateVNCResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ActivateVNCResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ActivateVNCResponse proto.InternalMessageInfo

func (m *ActivateVNCResponse) GetRequisites() *types.VNCRequisites {
	if m != nil {
		return m.Requisites
	}
	return nil
}

type AttachInputDeviceRequest struct {
	Name                 string                `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type                 types.InputDeviceType `protobuf:"varint,2,opt,name=type,proto3,enum=kvmrun.api.types.InputDeviceType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *AttachInputDeviceRequest) Reset()         { *m = AttachInputDeviceRequest{} }
func (m *AttachInputDeviceRequest) String() string { return proto.CompactTextString(m) }
func (*AttachInputDeviceRequest) ProtoMessage()    {}
func (*AttachInputDeviceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{20}
}
func (m *AttachInputDeviceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttachInputDeviceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttachInputDeviceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttachInputDeviceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachInputDeviceRequest.Merge(m, src)
}
func (m *AttachInputDeviceRequest) XXX_Size() int {
	return m.Size()
}
func (m *AttachInputDeviceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachInputDeviceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AttachInputDeviceRequest proto.InternalMessageInfo

func (m *AttachInputDeviceRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AttachInputDeviceRequest) GetType() types.InputDeviceType {
	if m != nil {
		return m.Type
	}
	return types.InputDeviceType_UNDEFINED_INPUT_TYPE
}

type DetachInputDeviceRequest struct {
	Name                 string                `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type                 types.InputDeviceType `protobuf:"varint,2,opt,name=type,proto3,enum=kvmrun.api.types.InputDeviceType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *DetachInputDeviceRequest) Reset()         { *m = DetachInputDeviceRequest{} }
func (m *DetachInputDeviceRequest) String() string { return proto.CompactTextString(m) }
func (*DetachInputDeviceRequest) ProtoMessage()    {}
func (*DetachInputDeviceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{21}
}
func (m *DetachInputDeviceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DetachInputDeviceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DetachInputDeviceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DetachInputDeviceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetachInputDeviceRequest.Merge(m, src)
}
func (m *DetachInputDeviceRequest) XXX_Size() int {
	return m.Size()
}
func (m *DetachInputDeviceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DetachInputDeviceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DetachInputDeviceRequest proto.InternalMessageInfo

func (m *DetachInputDeviceRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DetachInputDeviceRequest) GetType() types.InputDeviceType {
	if m != nil {
		return m.Type
	}
	return types.InputDeviceType_UNDEFINED_INPUT_TYPE
}

type AttachCdromRequest struct {
	Name                 string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	DeviceName           string            `protobuf:"bytes,2,opt,name=device_name,json=deviceName,proto3" json:"device_name,omitempty"`
	DeviceMedia          string            `protobuf:"bytes,3,opt,name=device_media,json=deviceMedia,proto3" json:"device_media,omitempty"`
	Driver               types.CdromDriver `protobuf:"varint,4,opt,name=driver,proto3,enum=kvmrun.api.types.CdromDriver" json:"driver,omitempty"`
	ReadOnly             bool              `protobuf:"varint,5,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
	Index                int32             `protobuf:"varint,6,opt,name=index,proto3" json:"index,omitempty"`
	Bootindex            int32             `protobuf:"varint,7,opt,name=bootindex,proto3" json:"bootindex,omitempty"`
	ProxyCommand         string            `protobuf:"bytes,8,opt,name=proxy_command,json=proxyCommand,proto3" json:"proxy_command,omitempty"`
	ProxyEnvs            map[string]string `protobuf:"bytes,9,rep,name=proxy_envs,json=proxyEnvs,proto3" json:"proxy_envs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Live                 bool              `protobuf:"varint,100,opt,name=live,proto3" json:"live,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *AttachCdromRequest) Reset()         { *m = AttachCdromRequest{} }
func (m *AttachCdromRequest) String() string { return proto.CompactTextString(m) }
func (*AttachCdromRequest) ProtoMessage()    {}
func (*AttachCdromRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{22}
}
func (m *AttachCdromRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttachCdromRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttachCdromRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttachCdromRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachCdromRequest.Merge(m, src)
}
func (m *AttachCdromRequest) XXX_Size() int {
	return m.Size()
}
func (m *AttachCdromRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachCdromRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AttachCdromRequest proto.InternalMessageInfo

func (m *AttachCdromRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AttachCdromRequest) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

func (m *AttachCdromRequest) GetDeviceMedia() string {
	if m != nil {
		return m.DeviceMedia
	}
	return ""
}

func (m *AttachCdromRequest) GetDriver() types.CdromDriver {
	if m != nil {
		return m.Driver
	}
	return types.CdromDriver_UNDEFINED_CDROM_DRIVER
}

func (m *AttachCdromRequest) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *AttachCdromRequest) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *AttachCdromRequest) GetBootindex() int32 {
	if m != nil {
		return m.Bootindex
	}
	return 0
}

func (m *AttachCdromRequest) GetProxyCommand() string {
	if m != nil {
		return m.ProxyCommand
	}
	return ""
}

func (m *AttachCdromRequest) GetProxyEnvs() map[string]string {
	if m != nil {
		return m.ProxyEnvs
	}
	return nil
}

func (m *AttachCdromRequest) GetLive() bool {
	if m != nil {
		return m.Live
	}
	return false
}

type DetachCdromRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	DeviceName           string   `protobuf:"bytes,2,opt,name=device_name,json=deviceName,proto3" json:"device_name,omitempty"`
	Live                 bool     `protobuf:"varint,100,opt,name=live,proto3" json:"live,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DetachCdromRequest) Reset()         { *m = DetachCdromRequest{} }
func (m *DetachCdromRequest) String() string { return proto.CompactTextString(m) }
func (*DetachCdromRequest) ProtoMessage()    {}
func (*DetachCdromRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{23}
}
func (m *DetachCdromRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DetachCdromRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DetachCdromRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DetachCdromRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetachCdromRequest.Merge(m, src)
}
func (m *DetachCdromRequest) XXX_Size() int {
	return m.Size()
}
func (m *DetachCdromRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DetachCdromRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DetachCdromRequest proto.InternalMessageInfo

func (m *DetachCdromRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DetachCdromRequest) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

func (m *DetachCdromRequest) GetLive() bool {
	if m != nil {
		return m.Live
	}
	return false
}

type ChangeCdromMediaRequest struct {
	Name                 string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	DeviceName           string            `protobuf:"bytes,2,opt,name=device_name,json=deviceName,proto3" json:"device_name,omitempty"`
	DeviceMedia          string            `protobuf:"bytes,3,opt,name=device_media,json=deviceMedia,proto3" json:"device_media,omitempty"`
	ProxyCommand         string            `protobuf:"bytes,4,opt,name=proxy_command,json=proxyCommand,proto3" json:"proxy_command,omitempty"`
	ProxyEnvs            map[string]string `protobuf:"bytes,5,rep,name=proxy_envs,json=proxyEnvs,proto3" json:"proxy_envs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Live                 bool              `protobuf:"varint,100,opt,name=live,proto3" json:"live,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ChangeCdromMediaRequest) Reset()         { *m = ChangeCdromMediaRequest{} }
func (m *ChangeCdromMediaRequest) String() string { return proto.CompactTextString(m) }
func (*ChangeCdromMediaRequest) ProtoMessage()    {}
func (*ChangeCdromMediaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{24}
}
func (m *ChangeCdromMediaRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangeCdromMediaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangeCdromMediaRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangeCdromMediaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeCdromMediaRequest.Merge(m, src)
}
func (m *ChangeCdromMediaRequest) XXX_Size() int {
	return m.Size()
}
func (m *ChangeCdromMediaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeCdromMediaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeCdromMediaRequest proto.InternalMessageInfo

func (m *ChangeCdromMediaRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ChangeCdromMediaRequest) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

func (m *ChangeCdromMediaRequest) GetDeviceMedia() string {
	if m != nil {
		return m.DeviceMedia
	}
	return ""
}

func (m *ChangeCdromMediaRequest) GetProxyCommand() string {
	if m != nil {
		return m.ProxyCommand
	}
	return ""
}

func (m *ChangeCdromMediaRequest) GetProxyEnvs() map[string]string {
	if m != nil {
		return m.ProxyEnvs
	}
	return nil
}

func (m *ChangeCdromMediaRequest) GetLive() bool {
	if m != nil {
		return m.Live
	}
	return false
}

type AttachDiskRequest struct {
	Name                 string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	DiskPath             string            `protobuf:"bytes,2,opt,name=disk_path,json=diskPath,proto3" json:"disk_path,omitempty"`
	Driver               types.DiskDriver  `protobuf:"varint,3,opt,name=driver,proto3,enum=kvmrun.api.types.DiskDriver" json:"driver,omitempty"`
	IopsRd               int32             `protobuf:"varint,4,opt,name=iops_rd,json=iopsRd,proto3" json:"iops_rd,omitempty"`
	IopsWr               int32             `protobuf:"varint,5,opt,name=iops_wr,json=iopsWr,proto3" json:"iops_wr,omitempty"`
	Index                int32             `protobuf:"varint,6,opt,name=index,proto3" json:"index,omitempty"`
	Bootindex            int32             `protobuf:"varint,7,opt,name=bootindex,proto3" json:"bootindex,omitempty"`
	ProxyCommand         string            `protobuf:"bytes,8,opt,name=proxy_command,json=proxyCommand,proto3" json:"proxy_command,omitempty"`
	ProxyEnvs            map[string]string `protobuf:"bytes,9,rep,name=proxy_envs,json=proxyEnvs,proto3" json:"proxy_envs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Live                 bool              `protobuf:"varint,100,opt,name=live,proto3" json:"live,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *AttachDiskRequest) Reset()         { *m = AttachDiskRequest{} }
func (m *AttachDiskRequest) String() string { return proto.CompactTextString(m) }
func (*AttachDiskRequest) ProtoMessage()    {}
func (*AttachDiskRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{25}
}
func (m *AttachDiskRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttachDiskRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttachDiskRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttachDiskRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachDiskRequest.Merge(m, src)
}
func (m *AttachDiskRequest) XXX_Size() int {
	return m.Size()
}
func (m *AttachDiskRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachDiskRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AttachDiskRequest proto.InternalMessageInfo

func (m *AttachDiskRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AttachDiskRequest) GetDiskPath() string {
	if m != nil {
		return m.DiskPath
	}
	return ""
}

func (m *AttachDiskRequest) GetDriver() types.DiskDriver {
	if m != nil {
		return m.Driver
	}
	return types.DiskDriver_UNDEFINED_DISK_DRIVER
}

func (m *AttachDiskRequest) GetIopsRd() int32 {
	if m != nil {
		return m.IopsRd
	}
	return 0
}

func (m *AttachDiskRequest) GetIopsWr() int32 {
	if m != nil {
		return m.IopsWr
	}
	return 0
}

func (m *AttachDiskRequest) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *AttachDiskRequest) GetBootindex() int32 {
	if m != nil {
		return m.Bootindex
	}
	return 0
}

func (m *AttachDiskRequest) GetProxyCommand() string {
	if m != nil {
		return m.ProxyCommand
	}
	return ""
}

func (m *AttachDiskRequest) GetProxyEnvs() map[string]string {
	if m != nil {
		return m.ProxyEnvs
	}
	return nil
}

func (m *AttachDiskRequest) GetLive() bool {
	if m != nil {
		return m.Live
	}
	return false
}

type DetachDiskRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	DiskName             string   `protobuf:"bytes,2,opt,name=disk_name,json=diskName,proto3" json:"disk_name,omitempty"`
	Live                 bool     `protobuf:"varint,100,opt,name=live,proto3" json:"live,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DetachDiskRequest) Reset()         { *m = DetachDiskRequest{} }
func (m *DetachDiskRequest) String() string { return proto.CompactTextString(m) }
func (*DetachDiskRequest) ProtoMessage()    {}
func (*DetachDiskRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{26}
}
func (m *DetachDiskRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DetachDiskRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DetachDiskRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DetachDiskRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetachDiskRequest.Merge(m, src)
}
func (m *DetachDiskRequest) XXX_Size() int {
	return m.Size()
}
func (m *DetachDiskRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DetachDiskRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DetachDiskRequest proto.InternalMessageInfo

func (m *DetachDiskRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DetachDiskRequest) GetDiskName() string {
	if m != nil {
		return m.DiskName
	}
	return ""
}

func (m *DetachDiskRequest) GetLive() bool {
	if m != nil {
		return m.Live
	}
	return false
}

type SetDiskLimitsRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	DiskName             string   `protobuf:"bytes,2,opt,name=disk_name,json=diskName,proto3" json:"disk_name,omitempty"`
	IopsRd               int32    `protobuf:"varint,3,opt,name=iops_rd,json=iopsRd,proto3" json:"iops_rd,omitempty"`
	IopsWr               int32    `protobuf:"varint,4,opt,name=iops_wr,json=iopsWr,proto3" json:"iops_wr,omitempty"`
	Live                 bool     `protobuf:"varint,100,opt,name=live,proto3" json:"live,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetDiskLimitsRequest) Reset()         { *m = SetDiskLimitsRequest{} }
func (m *SetDiskLimitsRequest) String() string { return proto.CompactTextString(m) }
func (*SetDiskLimitsRequest) ProtoMessage()    {}
func (*SetDiskLimitsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{27}
}
func (m *SetDiskLimitsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetDiskLimitsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetDiskLimitsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetDiskLimitsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetDiskLimitsRequest.Merge(m, src)
}
func (m *SetDiskLimitsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetDiskLimitsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetDiskLimitsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetDiskLimitsRequest proto.InternalMessageInfo

func (m *SetDiskLimitsRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SetDiskLimitsRequest) GetDiskName() string {
	if m != nil {
		return m.DiskName
	}
	return ""
}

func (m *SetDiskLimitsRequest) GetIopsRd() int32 {
	if m != nil {
		return m.IopsRd
	}
	return 0
}

func (m *SetDiskLimitsRequest) GetIopsWr() int32 {
	if m != nil {
		return m.IopsWr
	}
	return 0
}

func (m *SetDiskLimitsRequest) GetLive() bool {
	if m != nil {
		return m.Live
	}
	return false
}

type RemoveDiskBitmapRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	DiskName             string   `protobuf:"bytes,2,opt,name=disk_name,json=diskName,proto3" json:"disk_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoveDiskBitmapRequest) Reset()         { *m = RemoveDiskBitmapRequest{} }
func (m *RemoveDiskBitmapRequest) String() string { return proto.CompactTextString(m) }
func (*RemoveDiskBitmapRequest) ProtoMessage()    {}
func (*RemoveDiskBitmapRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{28}
}
func (m *RemoveDiskBitmapRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveDiskBitmapRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveDiskBitmapRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveDiskBitmapRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveDiskBitmapRequest.Merge(m, src)
}
func (m *RemoveDiskBitmapRequest) XXX_Size() int {
	return m.Size()
}
func (m *RemoveDiskBitmapRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveDiskBitmapRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveDiskBitmapRequest proto.InternalMessageInfo

func (m *RemoveDiskBitmapRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RemoveDiskBitmapRequest) GetDiskName() string {
	if m != nil {
		return m.DiskName
	}
	return ""
}

type ResizeQemuBlockdevRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	DiskName             string   `protobuf:"bytes,2,opt,name=disk_name,json=diskName,proto3" json:"disk_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResizeQemuBlockdevRequest) Reset()         { *m = ResizeQemuBlockdevRequest{} }
func (m *ResizeQemuBlockdevRequest) String() string { return proto.CompactTextString(m) }
func (*ResizeQemuBlockdevRequest) ProtoMessage()    {}
func (*ResizeQemuBlockdevRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{29}
}
func (m *ResizeQemuBlockdevRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResizeQemuBlockdevRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResizeQemuBlockdevRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResizeQemuBlockdevRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResizeQemuBlockdevRequest.Merge(m, src)
}
func (m *ResizeQemuBlockdevRequest) XXX_Size() int {
	return m.Size()
}
func (m *ResizeQemuBlockdevRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResizeQemuBlockdevRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResizeQemuBlockdevRequest proto.InternalMessageInfo

func (m *ResizeQemuBlockdevRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ResizeQemuBlockdevRequest) GetDiskName() string {
	if m != nil {
		return m.DiskName
	}
	return ""
}

type AttachNetIfaceRequest struct {
	Name                 string               `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Ifname               string               `protobuf:"bytes,2,opt,name=ifname,proto3" json:"ifname,omitempty"`
	Driver               types.NetIfaceDriver `protobuf:"varint,3,opt,name=driver,proto3,enum=kvmrun.api.types.NetIfaceDriver" json:"driver,omitempty"`
	HwAddr               string               `protobuf:"bytes,4,opt,name=hw_addr,json=hwAddr,proto3" json:"hw_addr,omitempty"`
	IfupScript           string               `protobuf:"bytes,5,opt,name=ifup_script,json=ifupScript,proto3" json:"ifup_script,omitempty"`
	IfdownScript         string               `protobuf:"bytes,6,opt,name=ifdown_script,json=ifdownScript,proto3" json:"ifdown_script,omitempty"`
	Live                 bool                 `protobuf:"varint,100,opt,name=live,proto3" json:"live,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *AttachNetIfaceRequest) Reset()         { *m = AttachNetIfaceRequest{} }
func (m *AttachNetIfaceRequest) String() string { return proto.CompactTextString(m) }
func (*AttachNetIfaceRequest) ProtoMessage()    {}
func (*AttachNetIfaceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{30}
}
func (m *AttachNetIfaceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttachNetIfaceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttachNetIfaceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttachNetIfaceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachNetIfaceRequest.Merge(m, src)
}
func (m *AttachNetIfaceRequest) XXX_Size() int {
	return m.Size()
}
func (m *AttachNetIfaceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachNetIfaceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AttachNetIfaceRequest proto.InternalMessageInfo

func (m *AttachNetIfaceRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AttachNetIfaceRequest) GetIfname() string {
	if m != nil {
		return m.Ifname
	}
	return ""
}

func (m *AttachNetIfaceRequest) GetDriver() types.NetIfaceDriver {
	if m != nil {
		return m.Driver
	}
	return types.NetIfaceDriver_UNDEFINED_NET_DRIVER
}

func (m *AttachNetIfaceRequest) GetHwAddr() string {
	if m != nil {
		return m.HwAddr
	}
	return ""
}

func (m *AttachNetIfaceRequest) GetIfupScript() string {
	if m != nil {
		return m.IfupScript
	}
	return ""
}

func (m *AttachNetIfaceRequest) GetIfdownScript() string {
	if m != nil {
		return m.IfdownScript
	}
	return ""
}

func (m *AttachNetIfaceRequest) GetLive() bool {
	if m != nil {
		return m.Live
	}
	return false
}

type DetachNetIfaceRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Ifname               string   `protobuf:"bytes,2,opt,name=ifname,proto3" json:"ifname,omitempty"`
	Live                 bool     `protobuf:"varint,100,opt,name=live,proto3" json:"live,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DetachNetIfaceRequest) Reset()         { *m = DetachNetIfaceRequest{} }
func (m *DetachNetIfaceRequest) String() string { return proto.CompactTextString(m) }
func (*DetachNetIfaceRequest) ProtoMessage()    {}
func (*DetachNetIfaceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{31}
}
func (m *DetachNetIfaceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DetachNetIfaceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DetachNetIfaceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DetachNetIfaceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetachNetIfaceRequest.Merge(m, src)
}
func (m *DetachNetIfaceRequest) XXX_Size() int {
	return m.Size()
}
func (m *DetachNetIfaceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DetachNetIfaceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DetachNetIfaceRequest proto.InternalMessageInfo

func (m *DetachNetIfaceRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DetachNetIfaceRequest) GetIfname() string {
	if m != nil {
		return m.Ifname
	}
	return ""
}

func (m *DetachNetIfaceRequest) GetLive() bool {
	if m != nil {
		return m.Live
	}
	return false
}

type SetNetIfaceScriptRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Ifname               string   `protobuf:"bytes,2,opt,name=ifname,proto3" json:"ifname,omitempty"`
	Path                 string   `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetNetIfaceScriptRequest) Reset()         { *m = SetNetIfaceScriptRequest{} }
func (m *SetNetIfaceScriptRequest) String() string { return proto.CompactTextString(m) }
func (*SetNetIfaceScriptRequest) ProtoMessage()    {}
func (*SetNetIfaceScriptRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{32}
}
func (m *SetNetIfaceScriptRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetNetIfaceScriptRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetNetIfaceScriptRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetNetIfaceScriptRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetNetIfaceScriptRequest.Merge(m, src)
}
func (m *SetNetIfaceScriptRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetNetIfaceScriptRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetNetIfaceScriptRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetNetIfaceScriptRequest proto.InternalMessageInfo

func (m *SetNetIfaceScriptRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SetNetIfaceScriptRequest) GetIfname() string {
	if m != nil {
		return m.Ifname
	}
	return ""
}

func (m *SetNetIfaceScriptRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type SetNetIfaceLinkRequest struct {
	Name                 string                  `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Ifname               string                  `protobuf:"bytes,2,opt,name=ifname,proto3" json:"ifname,omitempty"`
	State                types.NetIfaceLinkState `protobuf:"varint,3,opt,name=state,proto3,enum=kvmrun.api.types.NetIfaceLinkState" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *SetNetIfaceLinkRequest) Reset()         { *m = SetNetIfaceLinkRequest{} }
func (m *SetNetIfaceLinkRequest) String() string { return proto.CompactTextString(m) }
func (*SetNetIfaceLinkRequest) ProtoMessage()    {}
func (*SetNetIfaceLinkRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{33}
}
func (m *SetNetIfaceLinkRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetNetIfaceLinkRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetNetIfaceLinkRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetNetIfaceLinkRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetNetIfaceLinkRequest.Merge(m, src)
}
func (m *SetNetIfaceLinkRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetNetIfaceLinkRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetNetIfaceLinkRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetNetIfaceLinkRequest proto.InternalMessageInfo

func (m *SetNetIfaceLinkRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SetNetIfaceLinkRequest) GetIfname() string {
	if m != nil {
		return m.Ifname
	}
	return ""
}

func (m *SetNetIfaceLinkRequest) GetState() types.NetIfaceLinkState {
	if m != nil {
		return m.State
	}
	return types.NetIfaceLinkState_UNDEFINED_LINK_STATE
}

type AttachChannelRequest struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Types that are valid to be assigned to Channel:
	//	*AttachChannelRequest_Vsock
	//	*AttachChannelRequest_SerialPort
	Channel              isAttachChannelRequest_Channel `protobuf_oneof:"channel"`
	Live                 bool                           `protobuf:"varint,100,opt,name=live,proto3" json:"live,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *AttachChannelRequest) Reset()         { *m = AttachChannelRequest{} }
func (m *AttachChannelRequest) String() string { return proto.CompactTextString(m) }
func (*AttachChannelRequest) ProtoMessage()    {}
func (*AttachChannelRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{34}
}
func (m *AttachChannelRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttachChannelRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttachChannelRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttachChannelRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachChannelRequest.Merge(m, src)
}
func (m *AttachChannelRequest) XXX_Size() int {
	return m.Size()
}
func (m *AttachChannelRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachChannelRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AttachChannelRequest proto.InternalMessageInfo

type isAttachChannelRequest_Channel interface {
	isAttachChannelRequest_Channel()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AttachChannelRequest_Vsock struct {
	Vsock *AttachChannelRequest_VirtioVSock `protobuf:"bytes,2,opt,name=vsock,proto3,oneof" json:"vsock,omitempty"`
}
type AttachChannelRequest_SerialPort struct {
	SerialPort *AttachChannelRequest_VirtioSerialPort `protobuf:"bytes,3,opt,name=serial_port,json=serialPort,proto3,oneof" json:"serial_port,omitempty"`
}

func (*AttachChannelRequest_Vsock) isAttachChannelRequest_Channel()      {}
func (*AttachChannelRequest_SerialPort) isAttachChannelRequest_Channel() {}

func (m *AttachChannelRequest) GetChannel() isAttachChannelRequest_Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *AttachChannelRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AttachChannelRequest) GetVsock() *AttachChannelRequest_VirtioVSock {
	if x, ok := m.GetChannel().(*AttachChannelRequest_Vsock); ok {
		return x.Vsock
	}
	return nil
}

func (m *AttachChannelRequest) GetSerialPort() *AttachChannelRequest_VirtioSerialPort {
	if x, ok := m.GetChannel().(*AttachChannelRequest_SerialPort); ok {
		return x.SerialPort
	}
	return nil
}

func (m *AttachChannelRequest) GetLive() bool {
	if m != nil {
		return m.Live
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AttachChannelRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AttachChannelRequest_Vsock)(nil),
		(*AttachChannelRequest_SerialPort)(nil),
	}
}

type AttachChannelRequest_VirtioVSock struct {
	ContextID            uint32   `protobuf:"varint,1,opt,name=context_id,json=contextId,proto3" json:"context_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AttachChannelRequest_VirtioVSock) Reset()         { *m = AttachChannelRequest_VirtioVSock{} }
func (m *AttachChannelRequest_VirtioVSock) String() string { return proto.CompactTextString(m) }
func (*AttachChannelRequest_VirtioVSock) ProtoMessage()    {}
func (*AttachChannelRequest_VirtioVSock) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{34, 0}
}
func (m *AttachChannelRequest_VirtioVSock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttachChannelRequest_VirtioVSock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttachChannelRequest_VirtioVSock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttachChannelRequest_VirtioVSock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachChannelRequest_VirtioVSock.Merge(m, src)
}
func (m *AttachChannelRequest_VirtioVSock) XXX_Size() int {
	return m.Size()
}
func (m *AttachChannelRequest_VirtioVSock) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachChannelRequest_VirtioVSock.DiscardUnknown(m)
}

var xxx_messageInfo_AttachChannelRequest_VirtioVSock proto.InternalMessageInfo

func (m *AttachChannelRequest_VirtioVSock) GetContextID() uint32 {
	if m != nil {
		return m.ContextID
	}
	return 0
}

type AttachChannelRequest_VirtioSerialPort struct {
	PortID               string   `protobuf:"bytes,1,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty"`
	PortGuestName        string   `protobuf:"bytes,2,opt,name=port_guest_name,json=portGuestName,proto3" json:"port_guest_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AttachChannelRequest_VirtioSerialPort) Reset()         { *m = AttachChannelRequest_VirtioSerialPort{} }
func (m *AttachChannelRequest_VirtioSerialPort) String() string { return proto.CompactTextString(m) }
func (*AttachChannelRequest_VirtioSerialPort) ProtoMessage()    {}
func (*AttachChannelRequest_VirtioSerialPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{34, 1}
}
func (m *AttachChannelRequest_VirtioSerialPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttachChannelRequest_VirtioSerialPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttachChannelRequest_VirtioSerialPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttachChannelRequest_VirtioSerialPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachChannelRequest_VirtioSerialPort.Merge(m, src)
}
func (m *AttachChannelRequest_VirtioSerialPort) XXX_Size() int {
	return m.Size()
}
func (m *AttachChannelRequest_VirtioSerialPort) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachChannelRequest_VirtioSerialPort.DiscardUnknown(m)
}

var xxx_messageInfo_AttachChannelRequest_VirtioSerialPort proto.InternalMessageInfo

func (m *AttachChannelRequest_VirtioSerialPort) GetPortID() string {
	if m != nil {
		return m.PortID
	}
	return ""
}

func (m *AttachChannelRequest_VirtioSerialPort) GetPortGuestName() string {
	if m != nil {
		return m.PortGuestName
	}
	return ""
}

type DetachChannelRequest struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Types that are valid to be assigned to Channel:
	//	*DetachChannelRequest_Vsock
	//	*DetachChannelRequest_SerialPort
	Channel              isDetachChannelRequest_Channel `protobuf_oneof:"channel"`
	Live                 bool                           `protobuf:"varint,100,opt,name=live,proto3" json:"live,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *DetachChannelRequest) Reset()         { *m = DetachChannelRequest{} }
func (m *DetachChannelRequest) String() string { return proto.CompactTextString(m) }
func (*DetachChannelRequest) ProtoMessage()    {}
func (*DetachChannelRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{35}
}
func (m *DetachChannelRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DetachChannelRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DetachChannelRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DetachChannelRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetachChannelRequest.Merge(m, src)
}
func (m *DetachChannelRequest) XXX_Size() int {
	return m.Size()
}
func (m *DetachChannelRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DetachChannelRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DetachChannelRequest proto.InternalMessageInfo

type isDetachChannelRequest_Channel interface {
	isDetachChannelRequest_Channel()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DetachChannelRequest_Vsock struct {
	Vsock *DetachChannelRequest_VirtioVSock `protobuf:"bytes,2,opt,name=vsock,proto3,oneof" json:"vsock,omitempty"`
}
type DetachChannelRequest_SerialPort struct {
	SerialPort *DetachChannelRequest_VirtioSerialPort `protobuf:"bytes,3,opt,name=serial_port,json=serialPort,proto3,oneof" json:"serial_port,omitempty"`
}

func (*DetachChannelRequest_Vsock) isDetachChannelRequest_Channel()      {}
func (*DetachChannelRequest_SerialPort) isDetachChannelRequest_Channel() {}

func (m *DetachChannelRequest) GetChannel() isDetachChannelRequest_Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

func (m *DetachChannelRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DetachChannelRequest) GetVsock() *DetachChannelRequest_VirtioVSock {
	if x, ok := m.GetChannel().(*DetachChannelRequest_Vsock); ok {
		return x.Vsock
	}
	return nil
}

func (m *DetachChannelRequest) GetSerialPort() *DetachChannelRequest_VirtioSerialPort {
	if x, ok := m.GetChannel().(*DetachChannelRequest_SerialPort); ok {
		return x.SerialPort
	}
	return nil
}

func (m *DetachChannelRequest) GetLive() bool {
	if m != nil {
		return m.Live
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DetachChannelRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DetachChannelRequest_Vsock)(nil),
		(*DetachChannelRequest_SerialPort)(nil),
	}
}

type DetachChannelRequest_VirtioVSock struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DetachChannelRequest_VirtioVSock) Reset()         { *m = DetachChannelRequest_VirtioVSock{} }
func (m *DetachChannelRequest_VirtioVSock) String() string { return proto.CompactTextString(m) }
func (*DetachChannelRequest_VirtioVSock) ProtoMessage()    {}
func (*DetachChannelRequest_VirtioVSock) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{35, 0}
}
func (m *DetachChannelRequest_VirtioVSock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DetachChannelRequest_VirtioVSock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DetachChannelRequest_VirtioVSock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DetachChannelRequest_VirtioVSock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetachChannelRequest_VirtioVSock.Merge(m, src)
}
func (m *DetachChannelRequest_VirtioVSock) XXX_Size() int {
	return m.Size()
}
func (m *DetachChannelRequest_VirtioVSock) XXX_DiscardUnknown() {
	xxx_messageInfo_DetachChannelRequest_VirtioVSock.DiscardUnknown(m)
}

var xxx_messageInfo_DetachChannelRequest_VirtioVSock proto.InternalMessageInfo

type DetachChannelRequest_VirtioSerialPort struct {
	PortID               string   `protobuf:"bytes,1,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DetachChannelRequest_VirtioSerialPort) Reset()         { *m = DetachChannelRequest_VirtioSerialPort{} }
func (m *DetachChannelRequest_VirtioSerialPort) String() string { return proto.CompactTextString(m) }
func (*DetachChannelRequest_VirtioSerialPort) ProtoMessage()    {}
func (*DetachChannelRequest_VirtioSerialPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{35, 1}
}
func (m *DetachChannelRequest_VirtioSerialPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DetachChannelRequest_VirtioSerialPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DetachChannelRequest_VirtioSerialPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DetachChannelRequest_VirtioSerialPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetachChannelRequest_VirtioSerialPort.Merge(m, src)
}
func (m *DetachChannelRequest_VirtioSerialPort) XXX_Size() int {
	return m.Size()
}
func (m *DetachChannelRequest_VirtioSerialPort) XXX_DiscardUnknown() {
	xxx_messageInfo_DetachChannelRequest_VirtioSerialPort.DiscardUnknown(m)
}

var xxx_messageInfo_DetachChannelRequest_VirtioSerialPort proto.InternalMessageInfo

func (m *DetachChannelRequest_VirtioSerialPort) GetPortID() string {
	if m != nil {
		return m.PortID
	}
	return ""
}

type AttachCloudInitRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Path                 string   `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AttachCloudInitRequest) Reset()         { *m = AttachCloudInitRequest{} }
func (m *AttachCloudInitRequest) String() string { return proto.CompactTextString(m) }
func (*AttachCloudInitRequest) ProtoMessage()    {}
func (*AttachCloudInitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{36}
}
func (m *AttachCloudInitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttachCloudInitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttachCloudInitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttachCloudInitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachCloudInitRequest.Merge(m, src)
}
func (m *AttachCloudInitRequest) XXX_Size() int {
	return m.Size()
}
func (m *AttachCloudInitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachCloudInitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AttachCloudInitRequest proto.InternalMessageInfo

func (m *AttachCloudInitRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AttachCloudInitRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type DetachCloudInitRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DetachCloudInitRequest) Reset()         { *m = DetachCloudInitRequest{} }
func (m *DetachCloudInitRequest) String() string { return proto.CompactTextString(m) }
func (*DetachCloudInitRequest) ProtoMessage()    {}
func (*DetachCloudInitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{37}
}
func (m *DetachCloudInitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DetachCloudInitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DetachCloudInitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DetachCloudInitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetachCloudInitRequest.Merge(m, src)
}
func (m *DetachCloudInitRequest) XXX_Size() int {
	return m.Size()
}
func (m *DetachCloudInitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DetachCloudInitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DetachCloudInitRequest proto.InternalMessageInfo

func (m *DetachCloudInitRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ChangeCloudInitRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Path                 string   `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChangeCloudInitRequest) Reset()         { *m = ChangeCloudInitRequest{} }
func (m *ChangeCloudInitRequest) String() string { return proto.CompactTextString(m) }
func (*ChangeCloudInitRequest) ProtoMessage()    {}
func (*ChangeCloudInitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{38}
}
func (m *ChangeCloudInitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangeCloudInitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangeCloudInitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangeCloudInitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeCloudInitRequest.Merge(m, src)
}
func (m *ChangeCloudInitRequest) XXX_Size() int {
	return m.Size()
}
func (m *ChangeCloudInitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeCloudInitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeCloudInitRequest proto.InternalMessageInfo

func (m *ChangeCloudInitRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ChangeCloudInitRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type StartDiskBackupRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	DiskName             string   `protobuf:"bytes,2,opt,name=disk_name,json=diskName,proto3" json:"disk_name,omitempty"`
	Target               string   `protobuf:"bytes,3,opt,name=target,proto3" json:"target,omitempty"`
	Incremental          bool     `protobuf:"varint,4,opt,name=incremental,proto3" json:"incremental,omitempty"`
	ClearBitmap          bool     `protobuf:"varint,5,opt,name=clear_bitmap,json=clearBitmap,proto3" json:"clear_bitmap,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StartDiskBackupRequest) Reset()         { *m = StartDiskBackupRequest{} }
func (m *StartDiskBackupRequest) String() string { return proto.CompactTextString(m) }
func (*StartDiskBackupRequest) ProtoMessage()    {}
func (*StartDiskBackupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{39}
}
func (m *StartDiskBackupRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartDiskBackupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartDiskBackupRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartDiskBackupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartDiskBackupRequest.Merge(m, src)
}
func (m *StartDiskBackupRequest) XXX_Size() int {
	return m.Size()
}
func (m *StartDiskBackupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StartDiskBackupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StartDiskBackupRequest proto.InternalMessageInfo

func (m *StartDiskBackupRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *StartDiskBackupRequest) GetDiskName() string {
	if m != nil {
		return m.DiskName
	}
	return ""
}

func (m *StartDiskBackupRequest) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *StartDiskBackupRequest) GetIncremental() bool {
	if m != nil {
		return m.Incremental
	}
	return false
}

func (m *StartDiskBackupRequest) GetClearBitmap() bool {
	if m != nil {
		return m.ClearBitmap
	}
	return false
}

type StartBackupResponse struct {
	TaskKey              string   `protobuf:"bytes,1,opt,name=task_key,json=taskKey,proto3" json:"task_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StartBackupResponse) Reset()         { *m = StartBackupResponse{} }
func (m *StartBackupResponse) String() string { return proto.CompactTextString(m) }
func (*StartBackupResponse) ProtoMessage()    {}
func (*StartBackupResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{40}
}
func (m *StartBackupResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartBackupResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartBackupResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartBackupResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartBackupResponse.Merge(m, src)
}
func (m *StartBackupResponse) XXX_Size() int {
	return m.Size()
}
func (m *StartBackupResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StartBackupResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StartBackupResponse proto.InternalMessageInfo

func (m *StartBackupResponse) GetTaskKey() string {
	if m != nil {
		return m.TaskKey
	}
	return ""
}

type StartMigrationRequest struct {
	Name                 string                    `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	DstServer            string                    `protobuf:"bytes,2,opt,name=dst_server,json=dstServer,proto3" json:"dst_server,omitempty"`
	Disks                []string                  `protobuf:"bytes,3,rep,name=disks,proto3" json:"disks,omitempty"`
	Overrides            *types.MigrationOverrides `protobuf:"bytes,4,opt,name=overrides,proto3" json:"overrides,omitempty"`
	CreateDisks          bool                      `protobuf:"varint,5,opt,name=create_disks,json=createDisks,proto3" json:"create_disks,omitempty"`
	RemoveAfter          bool                      `protobuf:"varint,6,opt,name=remove_after,json=removeAfter,proto3" json:"remove_after,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *StartMigrationRequest) Reset()         { *m = StartMigrationRequest{} }
func (m *StartMigrationRequest) String() string { return proto.CompactTextString(m) }
func (*StartMigrationRequest) ProtoMessage()    {}
func (*StartMigrationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{41}
}
func (m *StartMigrationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartMigrationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartMigrationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartMigrationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartMigrationRequest.Merge(m, src)
}
func (m *StartMigrationRequest) XXX_Size() int {
	return m.Size()
}
func (m *StartMigrationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StartMigrationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StartMigrationRequest proto.InternalMessageInfo

func (m *StartMigrationRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *StartMigrationRequest) GetDstServer() string {
	if m != nil {
		return m.DstServer
	}
	return ""
}

func (m *StartMigrationRequest) GetDisks() []string {
	if m != nil {
		return m.Disks
	}
	return nil
}

func (m *StartMigrationRequest) GetOverrides() *types.MigrationOverrides {
	if m != nil {
		return m.Overrides
	}
	return nil
}

func (m *StartMigrationRequest) GetCreateDisks() bool {
	if m != nil {
		return m.CreateDisks
	}
	return false
}

func (m *StartMigrationRequest) GetRemoveAfter() bool {
	if m != nil {
		return m.RemoveAfter
	}
	return false
}

type StartMigrationResponse struct {
	TaskKey              string   `protobuf:"bytes,1,opt,name=task_key,json=taskKey,proto3" json:"task_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StartMigrationResponse) Reset()         { *m = StartMigrationResponse{} }
func (m *StartMigrationResponse) String() string { return proto.CompactTextString(m) }
func (*StartMigrationResponse) ProtoMessage()    {}
func (*StartMigrationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{42}
}
func (m *StartMigrationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartMigrationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartMigrationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartMigrationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartMigrationResponse.Merge(m, src)
}
func (m *StartMigrationResponse) XXX_Size() int {
	return m.Size()
}
func (m *StartMigrationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StartMigrationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StartMigrationResponse proto.InternalMessageInfo

func (m *StartMigrationResponse) GetTaskKey() string {
	if m != nil {
		return m.TaskKey
	}
	return ""
}

type SetExternalKernelRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Image                string   `protobuf:"bytes,2,opt,name=image,proto3" json:"image,omitempty"`
	Initrd               string   `protobuf:"bytes,3,opt,name=initrd,proto3" json:"initrd,omitempty"`
	Cmdline              string   `protobuf:"bytes,4,opt,name=cmdline,proto3" json:"cmdline,omitempty"`
	Modiso               string   `protobuf:"bytes,5,opt,name=modiso,proto3" json:"modiso,omitempty"`
	RemoveConf           bool     `protobuf:"varint,6,opt,name=remove_conf,json=removeConf,proto3" json:"remove_conf,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetExternalKernelRequest) Reset()         { *m = SetExternalKernelRequest{} }
func (m *SetExternalKernelRequest) String() string { return proto.CompactTextString(m) }
func (*SetExternalKernelRequest) ProtoMessage()    {}
func (*SetExternalKernelRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c764278a9df1350, []int{43}
}
func (m *SetExternalKernelRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetExternalKernelRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetExternalKernelRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetExternalKernelRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetExternalKernelRequest.Merge(m, src)
}
func (m *SetExternalKernelRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetExternalKernelRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetExternalKernelRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetExternalKernelRequest proto.InternalMessageInfo

func (m *SetExternalKernelRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SetExternalKernelRequest) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *SetExternalKernelRequest) GetInitrd() string {
	if m != nil {
		return m.Initrd
	}
	return ""
}

func (m *SetExternalKernelRequest) GetCmdline() string {
	if m != nil {
		return m.Cmdline
	}
	return ""
}

func (m *SetExternalKernelRequest) GetModiso() string {
	if m != nil {
		return m.Modiso
	}
	return ""
}

func (m *SetExternalKernelRequest) GetRemoveConf() bool {
	if m != nil {
		return m.RemoveConf
	}
	return false
}

func init() {
	proto.RegisterType((*CreateMachineRequest)(nil), "kvmrun.api.services.machines.v1.CreateMachineRequest")
	proto.RegisterMapType((map[string][]byte)(nil), "kvmrun.api.services.machines.v1.CreateMachineRequest.ExtraFilesEntry")
	proto.RegisterType((*CreateMachineResponse)(nil), "kvmrun.api.services.machines.v1.CreateMachineResponse")
	proto.RegisterType((*DeleteMachineRequest)(nil), "kvmrun.api.services.machines.v1.DeleteMachineRequest")
	proto.RegisterType((*DeleteMachineResponse)(nil), "kvmrun.api.services.machines.v1.DeleteMachineResponse")
	proto.RegisterType((*GetMachineRequest)(nil), "kvmrun.api.services.machines.v1.GetMachineRequest")
	proto.RegisterType((*GetMachineResponse)(nil), "kvmrun.api.services.machines.v1.GetMachineResponse")
	proto.RegisterType((*GetEventsResponse)(nil), "kvmrun.api.services.machines.v1.GetEventsResponse")
	proto.RegisterType((*StartMachineRequest)(nil), "kvmrun.api.services.machines.v1.StartMachineRequest")
	proto.RegisterType((*StopMachineRequest)(nil), "kvmrun.api.services.machines.v1.StopMachineRequest")
	proto.RegisterType((*RestartMachineRequest)(nil), "kvmrun.api.services.machines.v1.RestartMachineRequest")
	proto.RegisterType((*ListMachinesRequest)(nil), "kvmrun.api.services.machines.v1.ListMachinesRequest")
	proto.RegisterType((*ListMachinesResponse)(nil), "kvmrun.api.services.machines.v1.ListMachinesResponse")
	proto.RegisterType((*ListNamesResponse)(nil), "kvmrun.api.services.machines.v1.ListNamesResponse")
	proto.RegisterType((*SetMemLimitsRequest)(nil), "kvmrun.api.services.machines.v1.SetMemLimitsRequest")
	proto.RegisterType((*SetCPULimitsRequest)(nil), "kvmrun.api.services.machines.v1.SetCPULimitsRequest")
	proto.RegisterType((*SetCPUSocketsRequest)(nil), "kvmrun.api.services.machines.v1.SetCPUSocketsRequest")
	proto.RegisterType((*SetCPUQuotaRequest)(nil), "kvmrun.api.services.machines.v1.SetCPUQuotaRequest")
	proto.RegisterType((*SetCPUModelRequest)(nil), "kvmrun.api.services.machines.v1.SetCPUModelRequest")
	proto.RegisterType((*ActivateVNCRequest)(nil), "kvmrun.api.services.machines.v1.ActivateVNCRequest")
	proto.RegisterType((*ActivateVNCResponse)(nil), "kvmrun.api.services.machines.v1.ActivateVNCResponse")
	proto.RegisterType((*AttachInputDeviceRequest)(nil), "kvmrun.api.services.machines.v1.AttachInputDeviceRequest")
	proto.RegisterType((*DetachInputDeviceRequest)(nil), "kvmrun.api.services.machines.v1.DetachInputDeviceRequest")
	proto.RegisterType((*AttachCdromRequest)(nil), "kvmrun.api.services.machines.v1.AttachCdromRequest")
	proto.RegisterMapType((map[string]string)(nil), "kvmrun.api.services.machines.v1.AttachCdromRequest.ProxyEnvsEntry")
	proto.RegisterType((*DetachCdromRequest)(nil), "kvmrun.api.services.machines.v1.DetachCdromRequest")
	proto.RegisterType((*ChangeCdromMediaRequest)(nil), "kvmrun.api.services.machines.v1.ChangeCdromMediaRequest")
	proto.RegisterMapType((map[string]string)(nil), "kvmrun.api.services.machines.v1.ChangeCdromMediaRequest.ProxyEnvsEntry")
	proto.RegisterType((*AttachDiskRequest)(nil), "kvmrun.api.services.machines.v1.AttachDiskRequest")
	proto.RegisterMapType((map[string]string)(nil), "kvmrun.api.services.machines.v1.AttachDiskRequest.ProxyEnvsEntry")
	proto.RegisterType((*DetachDiskRequest)(nil), "kvmrun.api.services.machines.v1.DetachDiskRequest")
	proto.RegisterType((*SetDiskLimitsRequest)(nil), "kvmrun.api.services.machines.v1.SetDiskLimitsRequest")
	proto.RegisterType((*RemoveDiskBitmapRequest)(nil), "kvmrun.api.services.machines.v1.RemoveDiskBitmapRequest")
	proto.RegisterType((*ResizeQemuBlockdevRequest)(nil), "kvmrun.api.services.machines.v1.ResizeQemuBlockdevRequest")
	proto.RegisterType((*AttachNetIfaceRequest)(nil), "kvmrun.api.services.machines.v1.AttachNetIfaceRequest")
	proto.RegisterType((*DetachNetIfaceRequest)(nil), "kvmrun.api.services.machines.v1.DetachNetIfaceRequest")
	proto.RegisterType((*SetNetIfaceScriptRequest)(nil), "kvmrun.api.services.machines.v1.SetNetIfaceScriptRequest")
	proto.RegisterType((*SetNetIfaceLinkRequest)(nil), "kvmrun.api.services.machines.v1.SetNetIfaceLinkRequest")
	proto.RegisterType((*AttachChannelRequest)(nil), "kvmrun.api.services.machines.v1.AttachChannelRequest")
	proto.RegisterType((*AttachChannelRequest_VirtioVSock)(nil), "kvmrun.api.services.machines.v1.AttachChannelRequest.VirtioVSock")
	proto.RegisterType((*AttachChannelRequest_VirtioSerialPort)(nil), "kvmrun.api.services.machines.v1.AttachChannelRequest.VirtioSerialPort")
	proto.RegisterType((*DetachChannelRequest)(nil), "kvmrun.api.services.machines.v1.DetachChannelRequest")
	proto.RegisterType((*DetachChannelRequest_VirtioVSock)(nil), "kvmrun.api.services.machines.v1.DetachChannelRequest.VirtioVSock")
	proto.RegisterType((*DetachChannelRequest_VirtioSerialPort)(nil), "kvmrun.api.services.machines.v1.DetachChannelRequest.VirtioSerialPort")
	proto.RegisterType((*AttachCloudInitRequest)(nil), "kvmrun.api.services.machines.v1.AttachCloudInitRequest")
	proto.RegisterType((*DetachCloudInitRequest)(nil), "kvmrun.api.services.machines.v1.DetachCloudInitRequest")
	proto.RegisterType((*ChangeCloudInitRequest)(nil), "kvmrun.api.services.machines.v1.ChangeCloudInitRequest")
	proto.RegisterType((*StartDiskBackupRequest)(nil), "kvmrun.api.services.machines.v1.StartDiskBackupRequest")
	proto.RegisterType((*StartBackupResponse)(nil), "kvmrun.api.services.machines.v1.StartBackupResponse")
	proto.RegisterType((*StartMigrationRequest)(nil), "kvmrun.api.services.machines.v1.StartMigrationRequest")
	proto.RegisterType((*StartMigrationResponse)(nil), "kvmrun.api.services.machines.v1.StartMigrationResponse")
	proto.RegisterType((*SetExternalKernelRequest)(nil), "kvmrun.api.services.machines.v1.SetExternalKernelRequest")
}

func init() {
	proto.RegisterFile("services/machines/v1/machines.proto", fileDescriptor_1c764278a9df1350)
}

var fileDescriptor_1c764278a9df1350 = []byte{
	// 2349 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x5a, 0x4b, 0x73, 0xdb, 0xc8,
	0x11, 0x16, 0x4d, 0x91, 0x12, 0x9a, 0x92, 0xd7, 0x1e, 0xcb, 0x32, 0x4d, 0xef, 0xda, 0x32, 0x9c,
	0x4a, 0x5c, 0x95, 0x0d, 0xb5, 0x2b, 0x59, 0x7e, 0x6d, 0x92, 0x5d, 0x4b, 0xd4, 0xda, 0x8a, 0xe5,
	0xc7, 0x82, 0xb1, 0x9d, 0x75, 0x1e, 0x34, 0x44, 0x0c, 0xc5, 0x89, 0x08, 0x0c, 0x0c, 0x0c, 0x29,
	0x71, 0x2f, 0x39, 0x27, 0x55, 0xf9, 0x07, 0x39, 0xe7, 0x90, 0xaa, 0x54, 0xce, 0xf9, 0x07, 0x39,
	0xa5, 0xf6, 0x96, 0xdb, 0x56, 0xca, 0xc7, 0x9c, 0xf2, 0x13, 0x52, 0xf3, 0x00, 0x05, 0x12, 0x10,
	0x38, 0xa2, 0x22, 0x5f, 0x54, 0x98, 0x46, 0xf7, 0xf7, 0xcd, 0x4c, 0x4f, 0xcf, 0x0c, 0x3e, 0x11,
	0x6e, 0x84, 0x38, 0xe8, 0x91, 0x26, 0x0e, 0x97, 0x5d, 0xbb, 0xd9, 0x26, 0x1e, 0x0e, 0x97, 0x7b,
	0x9f, 0x0e, 0x9e, 0xab, 0x7e, 0x40, 0x19, 0x45, 0xd7, 0xf6, 0x7a, 0x6e, 0xd0, 0xf5, 0xaa, 0xb6,
	0x4f, 0xaa, 0x91, 0x7f, 0x75, 0xe0, 0xd3, 0xfb, 0xb4, 0x72, 0x65, 0x97, 0xd2, 0xdd, 0x0e, 0x5e,
	0x16, 0xee, 0x3b, 0xdd, 0xd6, 0x32, 0x76, 0x7d, 0xd6, 0x97, 0xd1, 0x95, 0x1f, 0xed, 0x12, 0xd6,
	0xee, 0xee, 0x54, 0x9b, 0xd4, 0x5d, 0xde, 0xa5, 0xbb, 0xf4, 0xd0, 0x8b, 0xb7, 0x44, 0x43, 0x3c,
	0x29, 0xf7, 0xf3, 0xac, 0xef, 0xe3, 0x70, 0x59, 0xfc, 0x95, 0x26, 0xf3, 0x2f, 0x67, 0x60, 0x61,
	0x23, 0xc0, 0x36, 0xc3, 0x4f, 0x24, 0xa9, 0x85, 0xdf, 0x76, 0x71, 0xc8, 0x10, 0x82, 0x69, 0xcf,
	0x76, 0x71, 0x39, 0xb7, 0x94, 0xbb, 0x69, 0x58, 0xe2, 0x19, 0xdd, 0x81, 0x19, 0xea, 0x33, 0x42,
	0xbd, 0xb0, 0x7c, 0x66, 0x29, 0x77, 0xb3, 0xb4, 0xf2, 0x51, 0x35, 0xd6, 0x7d, 0x09, 0xab, 0x60,
	0x9e, 0xf9, 0x2c, 0xb4, 0x22, 0x6f, 0x74, 0x15, 0xc0, 0xc7, 0x41, 0x48, 0x42, 0x86, 0x3d, 0x56,
	0xce, 0x2f, 0xe5, 0x6e, 0xce, 0x5a, 0x31, 0x0b, 0x6a, 0x41, 0x09, 0x1f, 0xb0, 0xc0, 0x6e, 0xb4,
	0x48, 0x07, 0x87, 0xe5, 0xe9, 0xa5, 0xfc, 0xcd, 0xd2, 0xca, 0x66, 0x75, 0xcc, 0xdc, 0x54, 0xd3,
	0x3a, 0x5e, 0xdd, 0xe4, 0x40, 0x5f, 0x72, 0x9c, 0x4d, 0x8f, 0x05, 0x7d, 0x0b, 0xf0, 0xc0, 0x50,
	0xf9, 0x09, 0x7c, 0x30, 0xf2, 0x1a, 0x9d, 0x83, 0xfc, 0x1e, 0xee, 0xab, 0x61, 0xf2, 0x47, 0xb4,
	0x00, 0x85, 0x9e, 0xdd, 0xe9, 0x62, 0x31, 0xc6, 0x39, 0x4b, 0x36, 0xee, 0x9f, 0xb9, 0x9b, 0x33,
	0xb7, 0xe1, 0xe2, 0x08, 0x65, 0xe8, 0x53, 0x2f, 0xc4, 0x68, 0x15, 0x66, 0x54, 0xbf, 0x04, 0x50,
	0x69, 0xe5, 0xf2, 0x91, 0x13, 0x63, 0x45, 0x9e, 0xe6, 0x17, 0xb0, 0x50, 0xc3, 0x1d, 0xac, 0x35,
	0xf3, 0x0b, 0x50, 0x68, 0xd1, 0xa0, 0x29, 0xfb, 0x34, 0x6b, 0xc9, 0x06, 0xef, 0xcf, 0x08, 0xc2,
	0x49, 0xfa, 0xf3, 0x03, 0x38, 0xff, 0x10, 0xb3, 0xf1, 0x9d, 0x31, 0xb7, 0x00, 0xc5, 0x1d, 0x4f,
	0xc2, 0xf9, 0x58, 0x70, 0x6e, 0xf6, 0xb0, 0xc7, 0xc2, 0x01, 0xd2, 0x6d, 0x28, 0x62, 0x61, 0x29,
	0xe7, 0xc4, 0x42, 0xb8, 0x7a, 0x24, 0x90, 0x08, 0xb4, 0x94, 0xb7, 0xf9, 0x14, 0x2e, 0xd4, 0x99,
	0x1d, 0x68, 0x0c, 0x01, 0xdd, 0x80, 0xf9, 0x7d, 0x9b, 0xb0, 0x06, 0xf1, 0x18, 0x0e, 0x7a, 0x76,
	0x47, 0xcc, 0x6b, 0xc1, 0x9a, 0xe3, 0xc6, 0x2d, 0x65, 0x33, 0x2d, 0x40, 0x75, 0x46, 0x7d, 0x0d,
	0x38, 0x04, 0xd3, 0x3c, 0x52, 0x65, 0x47, 0x3c, 0x1f, 0xa6, 0x2c, 0x1f, 0x4f, 0xd9, 0xe7, 0x70,
	0xd1, 0xc2, 0xa1, 0x66, 0x2f, 0x53, 0x60, 0xcd, 0x1f, 0xc2, 0x85, 0x6d, 0x12, 0x46, 0xd1, 0x61,
	0x14, 0xbe, 0x00, 0x05, 0x1e, 0x22, 0xa7, 0xcc, 0xb0, 0x64, 0xc3, 0x7c, 0x02, 0x0b, 0xc3, 0xce,
	0x6a, 0x86, 0xd7, 0x60, 0x36, 0xaa, 0x23, 0x35, 0xc7, 0x19, 0xc9, 0x1a, 0xb8, 0x9a, 0xcb, 0x70,
	0x9e, 0xc3, 0x3d, 0xe5, 0xd8, 0x03, 0xac, 0xca, 0x08, 0x96, 0x11, 0x0b, 0xd8, 0x83, 0x0b, 0x75,
	0xcc, 0x9e, 0x60, 0x77, 0x9b, 0xb8, 0x84, 0x85, 0x59, 0x63, 0x5d, 0x84, 0xa2, 0xdd, 0x64, 0x5d,
	0x95, 0x8a, 0xbc, 0xa5, 0x5a, 0x7c, 0x60, 0x8c, 0x32, 0xbb, 0x23, 0xa6, 0x31, 0x6f, 0xc9, 0x06,
	0x47, 0xe8, 0x90, 0x1e, 0x2e, 0x3b, 0x72, 0x66, 0xf8, 0xb3, 0x22, 0xdb, 0x78, 0xfe, 0xe2, 0x7d,
	0x90, 0xd5, 0x60, 0x41, 0x92, 0xd5, 0x69, 0x73, 0x0f, 0x67, 0xb3, 0x95, 0x61, 0x26, 0x94, 0x5e,
	0x6a, 0x99, 0x45, 0x4d, 0xb1, 0xc2, 0x04, 0xca, 0x57, 0x5d, 0xca, 0xec, 0x31, 0x1b, 0xc0, 0x5b,
	0xee, 0xa3, 0x10, 0x64, 0x23, 0xb5, 0x67, 0x3f, 0x8d, 0x30, 0x9f, 0x50, 0x07, 0x77, 0xc6, 0x60,
	0xba, 0xdc, 0x47, 0x60, 0x1a, 0x96, 0x6c, 0x98, 0x35, 0x40, 0x0f, 0x9a, 0x8c, 0xf4, 0x6c, 0x86,
	0x5f, 0x3e, 0xdd, 0xc8, 0x8a, 0xaf, 0xc0, 0xac, 0x6f, 0x87, 0xe1, 0x3e, 0x0d, 0x1c, 0x05, 0x31,
	0x68, 0x9b, 0x2f, 0xe1, 0xc2, 0x10, 0x8a, 0x5a, 0x2c, 0x9f, 0x03, 0x04, 0xf8, 0x6d, 0x97, 0x84,
	0x84, 0x89, 0xe5, 0xc2, 0xf7, 0x89, 0x6b, 0xc9, 0xa5, 0xa7, 0x88, 0xa5, 0x9b, 0x15, 0x0b, 0x31,
	0x31, 0x94, 0x1f, 0x30, 0x66, 0x37, 0xdb, 0x5b, 0x9e, 0xdf, 0x65, 0x35, 0xcc, 0x0f, 0x85, 0xac,
	0x3e, 0xae, 0xc1, 0x34, 0x87, 0x14, 0xfd, 0x3b, 0xbb, 0x72, 0x3d, 0x49, 0x15, 0xc3, 0xf9, 0x79,
	0xdf, 0xc7, 0x96, 0x70, 0xe7, 0x34, 0x35, 0x7c, 0xfa, 0x34, 0xff, 0xcc, 0x03, 0x92, 0xc3, 0xd9,
	0x70, 0x02, 0xea, 0x66, 0x31, 0x5c, 0x83, 0x92, 0x23, 0xc2, 0x1b, 0xe2, 0x95, 0x9c, 0x6f, 0x90,
	0x26, 0x5e, 0x90, 0xe8, 0x3a, 0xcc, 0x29, 0x07, 0x17, 0x3b, 0xc4, 0x16, 0x4b, 0xd8, 0xb0, 0x54,
	0xd0, 0x13, 0x6e, 0x42, 0x6b, 0x50, 0x74, 0x02, 0xd2, 0xc3, 0x41, 0x79, 0x5a, 0xf4, 0x33, 0xe5,
	0xf8, 0x16, 0xfd, 0xa8, 0x09, 0x27, 0x4b, 0x39, 0xa3, 0x2b, 0x60, 0x04, 0xd8, 0x76, 0x1a, 0xd4,
	0xeb, 0xf4, 0xcb, 0x05, 0xb1, 0xd4, 0x66, 0xb9, 0xe1, 0x99, 0xd7, 0x11, 0xa7, 0x25, 0xf1, 0x1c,
	0x7c, 0x50, 0x2e, 0xca, 0x85, 0x29, 0x1a, 0xe8, 0x43, 0x30, 0x76, 0x28, 0x65, 0xf2, 0xcd, 0x8c,
	0x78, 0x73, 0x68, 0xe0, 0xbb, 0xaf, 0x1f, 0xd0, 0x83, 0x7e, 0xa3, 0x49, 0x5d, 0xd7, 0xf6, 0x9c,
	0xf2, 0xac, 0xe8, 0xeb, 0x9c, 0x30, 0x6e, 0x48, 0x1b, 0xb2, 0x01, 0xa4, 0x13, 0xf6, 0x7a, 0x61,
	0xd9, 0x10, 0xbb, 0xd4, 0xfa, 0xd8, 0x2b, 0x41, 0x72, 0x36, 0xab, 0xcf, 0x39, 0xca, 0xa6, 0xd7,
	0x53, 0xf7, 0x01, 0xc3, 0x8f, 0xda, 0x69, 0xe5, 0x53, 0xf9, 0x31, 0x9c, 0x1d, 0x0e, 0x18, 0x77,
	0x43, 0x30, 0xe2, 0x37, 0x84, 0x5f, 0x03, 0x92, 0xeb, 0xe6, 0xe4, 0xf9, 0x4c, 0xab, 0xed, 0x6f,
	0xcf, 0xc0, 0xa5, 0x8d, 0xb6, 0xed, 0xed, 0x62, 0x81, 0x2f, 0xb2, 0x7a, 0xda, 0x8b, 0x26, 0x91,
	0xac, 0xe9, 0x94, 0x64, 0xb5, 0x86, 0x92, 0x55, 0x10, 0xc9, 0x7a, 0x38, 0xfe, 0xfe, 0x96, 0x3e,
	0x94, 0xf7, 0x9a, 0xb1, 0xbf, 0xe7, 0xe1, 0xbc, 0x5c, 0x34, 0x35, 0x12, 0xee, 0x65, 0x4d, 0xe6,
	0x15, 0x30, 0x1c, 0x12, 0xee, 0x35, 0x7c, 0x9b, 0xb5, 0xa3, 0xfd, 0x8e, 0x1b, 0x9e, 0xdb, 0xac,
	0x8d, 0x6e, 0x0d, 0x4a, 0x2b, 0x2f, 0x4a, 0xeb, 0xc3, 0x64, 0x69, 0x71, 0xfc, 0x91, 0xca, 0xba,
	0x04, 0x33, 0x84, 0xfa, 0x61, 0x23, 0x90, 0xb3, 0x5a, 0xb0, 0x8a, 0xbc, 0x69, 0x39, 0x83, 0x17,
	0xfb, 0x81, 0x28, 0x38, 0xf5, 0xe2, 0x55, 0x70, 0x7a, 0xe5, 0xf6, 0x26, 0xa5, 0xdc, 0x1e, 0x68,
	0x96, 0x5b, 0x6c, 0xe6, 0xde, 0x6b, 0xee, 0x7e, 0x01, 0xe7, 0x65, 0xb5, 0xe9, 0xa6, 0x2e, 0x56,
	0x05, 0x22, 0x75, 0x47, 0x16, 0xda, 0x1f, 0x73, 0xe2, 0x7c, 0xe7, 0xb8, 0xe3, 0x6f, 0x13, 0x99,
	0xe8, 0xb1, 0x14, 0xe7, 0x8f, 0x4a, 0xf1, 0xf4, 0x50, 0x8a, 0xd3, 0xfa, 0xf3, 0x33, 0xb8, 0x64,
	0x61, 0x97, 0xf6, 0x30, 0xef, 0xd1, 0x3a, 0x61, 0xae, 0xed, 0x4f, 0xda, 0x23, 0x73, 0x1b, 0x2e,
	0x5b, 0x38, 0x24, 0xdf, 0xe0, 0xaf, 0xb0, 0xdb, 0x5d, 0xef, 0xd0, 0xe6, 0x9e, 0x83, 0x7b, 0x13,
	0xa3, 0xfd, 0x37, 0x07, 0x17, 0xe5, 0x2a, 0x78, 0x8a, 0xd9, 0x56, 0xcb, 0xce, 0x3e, 0x27, 0x17,
	0xa1, 0x48, 0x5a, 0x31, 0x1c, 0xd5, 0x42, 0x77, 0x47, 0xca, 0x67, 0x29, 0x59, 0x3e, 0x11, 0x7c,
	0xb2, 0x84, 0xda, 0xfb, 0x0d, 0xdb, 0x71, 0x02, 0xb5, 0x31, 0x15, 0xdb, 0xfb, 0x0f, 0x1c, 0x27,
	0xe0, 0x7b, 0x1f, 0x69, 0x75, 0xfd, 0x46, 0xd8, 0x0c, 0x88, 0xcf, 0x44, 0x19, 0x19, 0x16, 0x70,
	0x53, 0x5d, 0x58, 0x78, 0x59, 0x90, 0x96, 0x43, 0xf7, 0xbd, 0xc8, 0xa5, 0x28, 0xcb, 0x42, 0x1a,
	0x95, 0x53, 0x5a, 0x32, 0x5e, 0xf1, 0xcf, 0xae, 0x93, 0x8e, 0x38, 0x0d, 0xf8, 0x35, 0x94, 0xeb,
	0x98, 0x45, 0xa8, 0xb2, 0x07, 0x13, 0x62, 0x8b, 0x4d, 0x4a, 0xee, 0xe6, 0xe2, 0xd9, 0xfc, 0x1d,
	0x2c, 0xc6, 0xb0, 0xb7, 0x89, 0xb7, 0x37, 0x09, 0xf2, 0x3d, 0x28, 0x84, 0xcc, 0x66, 0x58, 0xa5,
	0xe9, 0xc6, 0xd1, 0x69, 0xe2, 0x0c, 0x75, 0xee, 0x6a, 0xc9, 0x08, 0xf3, 0xaf, 0x79, 0x58, 0x50,
	0xa7, 0x73, 0xdb, 0xf6, 0xbc, 0xec, 0xab, 0xe9, 0xd7, 0x50, 0xe8, 0xf1, 0x4b, 0xb2, 0xd2, 0x19,
	0x74, 0x37, 0xa2, 0x61, 0xe4, 0xea, 0x4b, 0x12, 0x30, 0x42, 0x5f, 0xf2, 0x2b, 0xfa, 0xa3, 0x29,
	0x4b, 0x22, 0x22, 0x02, 0xa5, 0x10, 0x07, 0xc4, 0xee, 0x34, 0x7c, 0x1a, 0x48, 0x31, 0xa2, 0xb4,
	0xf2, 0xe5, 0x49, 0x08, 0xea, 0x02, 0xee, 0x39, 0x0d, 0xd8, 0xa3, 0x29, 0x0b, 0xc2, 0x41, 0x2b,
	0x75, 0xc7, 0xfb, 0x0c, 0x4a, 0xb1, 0x6e, 0xa1, 0x8f, 0x01, 0x9a, 0xd4, 0x63, 0xf8, 0x80, 0x35,
	0x88, 0x23, 0xa6, 0x60, 0x7e, 0x7d, 0xfe, 0xdd, 0x77, 0xd7, 0x8c, 0x0d, 0x69, 0xdd, 0xaa, 0x59,
	0x86, 0x72, 0xd8, 0x72, 0x2a, 0x0d, 0x38, 0x37, 0x4a, 0x89, 0x6e, 0xc0, 0x0c, 0x1f, 0x48, 0x14,
	0x6e, 0xac, 0xc3, 0xbb, 0xef, 0xae, 0x15, 0xf9, 0xab, 0xad, 0x9a, 0x55, 0xe4, 0xaf, 0xb6, 0x1c,
	0xf4, 0x7d, 0xf8, 0x40, 0x38, 0xed, 0xf2, 0x6e, 0xc7, 0x0b, 0x79, 0x9e, 0x9b, 0x1f, 0x72, 0x2b,
	0xaf, 0xe6, 0x75, 0x03, 0x66, 0x9a, 0x72, 0x88, 0xe6, 0xbf, 0xce, 0xc0, 0x82, 0xba, 0xcb, 0x9c,
	0x42, 0xbe, 0xd2, 0x90, 0xff, 0xaf, 0xf9, 0xca, 0x20, 0x38, 0x56, 0xbe, 0xe6, 0x87, 0xf2, 0x55,
	0xb9, 0x33, 0x61, 0x06, 0xe2, 0x33, 0xfb, 0x05, 0x2c, 0xaa, 0xd5, 0xd4, 0xa1, 0x5d, 0x67, 0xcb,
	0x23, 0x6c, 0x8c, 0x08, 0x10, 0xbb, 0x71, 0xc8, 0x62, 0xfe, 0x18, 0x16, 0xd5, 0xf8, 0x34, 0x10,
	0x38, 0x9f, 0xba, 0x69, 0x4d, 0xca, 0xf7, 0xe7, 0x1c, 0x2c, 0x0a, 0x69, 0x45, 0x1c, 0x3f, 0x76,
	0x73, 0xaf, 0x3b, 0xf1, 0xf1, 0xc3, 0xb7, 0x16, 0x66, 0x07, 0xbb, 0x98, 0xa9, 0xed, 0x49, 0xb5,
	0xd0, 0x12, 0x94, 0x88, 0xd7, 0x0c, 0xb0, 0x8b, 0x3d, 0xfe, 0x05, 0x3e, 0x2d, 0x72, 0x10, 0x37,
	0xf1, 0xcb, 0x6a, 0xb3, 0x83, 0xed, 0xa0, 0xb1, 0x23, 0x0e, 0x40, 0xf5, 0x29, 0x52, 0x12, 0x36,
	0x79, 0x26, 0x9a, 0x9f, 0x28, 0x09, 0x28, 0xea, 0xa3, 0xfa, 0xec, 0xbc, 0x0c, 0xb3, 0xcc, 0x0e,
	0xf7, 0x1a, 0x87, 0x37, 0x8b, 0x19, 0xde, 0x7e, 0x8c, 0xfb, 0xe6, 0x7f, 0x72, 0x70, 0x51, 0xaa,
	0x46, 0x64, 0x37, 0xb0, 0x19, 0xa1, 0x5e, 0xd6, 0xc8, 0x3e, 0x02, 0x70, 0x42, 0xd6, 0xe0, 0x2b,
	0x0e, 0x07, 0x6a, 0x68, 0x86, 0x13, 0xb2, 0xba, 0x30, 0xf0, 0xab, 0x0a, 0x1f, 0x67, 0x58, 0xce,
	0x4b, 0x15, 0x46, 0x34, 0xd0, 0x3a, 0x18, 0xb4, 0x87, 0x83, 0x80, 0x38, 0x42, 0xdb, 0xe4, 0xeb,
	0xf7, 0x7b, 0x29, 0x72, 0x4b, 0xc4, 0xff, 0x2c, 0xf2, 0xb5, 0x0e, 0xc3, 0xc4, 0xd8, 0x85, 0xf4,
	0xd8, 0x90, 0x04, 0xd1, 0xd8, 0x85, 0xad, 0x26, 0x68, 0xae, 0xc3, 0x5c, 0x20, 0xee, 0x08, 0x0d,
	0xbb, 0xc5, 0x70, 0x20, 0x8e, 0xb3, 0x59, 0xab, 0x24, 0x6d, 0x0f, 0xb8, 0xc9, 0x5c, 0x55, 0x69,
	0x8c, 0x8d, 0x75, 0xfc, 0x0c, 0xfd, 0x2d, 0x27, 0x8e, 0xa5, 0xcd, 0x03, 0x86, 0x03, 0xcf, 0xee,
	0x3c, 0xc6, 0x81, 0x37, 0x56, 0x57, 0x20, 0xae, 0xbd, 0x3b, 0xb8, 0xb0, 0x89, 0x86, 0x38, 0x52,
	0x3c, 0xc2, 0xd4, 0x3d, 0x88, 0x1f, 0x29, 0xa2, 0x85, 0xca, 0x30, 0xd3, 0x74, 0x9d, 0x0e, 0xf1,
	0xb0, 0x3a, 0xc0, 0xa3, 0x26, 0x8f, 0x70, 0xa9, 0x43, 0x42, 0xaa, 0x0e, 0x6f, 0xd5, 0xe2, 0x27,
	0xbb, 0x1a, 0x68, 0x93, 0x7a, 0x2d, 0x35, 0x4e, 0x90, 0xa6, 0x0d, 0xea, 0xb5, 0x56, 0xfe, 0xb4,
	0x04, 0x67, 0x95, 0x7a, 0x55, 0x97, 0x7b, 0x03, 0xea, 0x43, 0x51, 0x4a, 0xb7, 0x68, 0x6d, 0x22,
	0x59, 0xb9, 0x72, 0xfb, 0xb8, 0x61, 0x72, 0x62, 0xcd, 0x29, 0x4e, 0x2d, 0x55, 0x5a, 0x0d, 0xea,
	0x34, 0x41, 0x58, 0x83, 0x3a, 0x55, 0x05, 0x36, 0xa7, 0x90, 0x0f, 0xf9, 0x87, 0x98, 0xa1, 0x95,
	0xb1, 0x00, 0x09, 0xe1, 0xb7, 0xb2, 0x7a, 0xac, 0x98, 0x01, 0x63, 0x17, 0x8c, 0x81, 0xa0, 0x3b,
	0x11, 0xaf, 0x56, 0xcc, 0xb0, 0x60, 0x6c, 0x4e, 0xa1, 0x57, 0x50, 0x10, 0x0b, 0x1b, 0xdd, 0x1a,
	0x1b, 0x9e, 0x22, 0x11, 0x57, 0x16, 0xab, 0xf2, 0xbf, 0x2c, 0xd5, 0xe8, 0xff, 0x27, 0xd5, 0x4d,
	0xd7, 0x67, 0x7d, 0x73, 0x0a, 0xbd, 0x80, 0xe9, 0x3a, 0xa3, 0x3e, 0x5a, 0xd5, 0xc0, 0x1d, 0x95,
	0x8a, 0x33, 0x60, 0x7f, 0x09, 0x33, 0x4a, 0x06, 0x46, 0xe3, 0xb3, 0x9b, 0x2a, 0x18, 0x67, 0x80,
	0x7f, 0x0d, 0x05, 0x0b, 0x87, 0xf8, 0x34, 0xa0, 0xbb, 0x30, 0xbd, 0x4d, 0x42, 0x9d, 0x69, 0x4e,
	0x11, 0xa9, 0x2b, 0x6b, 0xc7, 0x8c, 0x1a, 0xa4, 0x77, 0x1f, 0x8c, 0x81, 0xf0, 0x3c, 0x21, 0xf7,
	0x8a, 0x56, 0xd4, 0x90, 0xb4, 0x6d, 0x4e, 0xa1, 0xdf, 0xc0, 0x5c, 0x5c, 0xc0, 0xd6, 0x59, 0x5e,
	0x49, 0xbd, 0x3b, 0x63, 0x3e, 0x25, 0xfe, 0x40, 0xb3, 0xd6, 0xc3, 0x1f, 0x95, 0xb8, 0x33, 0xf0,
	0xdf, 0xc0, 0xfc, 0x90, 0x4c, 0xad, 0xb1, 0x05, 0xa5, 0xc9, 0xda, 0x19, 0x0c, 0xbf, 0x82, 0x52,
	0x4c, 0xc2, 0xd6, 0xa9, 0x93, 0x84, 0xe0, 0xad, 0x83, 0x2e, 0xc4, 0x6c, 0x6d, 0xf4, 0xb8, 0xf4,
	0x9d, 0x81, 0xfe, 0x0d, 0x94, 0x62, 0x22, 0xb5, 0x06, 0x7a, 0x52, 0x18, 0xaf, 0xdc, 0x3a, 0x5e,
	0xd0, 0x60, 0x65, 0xb5, 0x23, 0xd9, 0x29, 0xa6, 0x0c, 0xa3, 0x7b, 0x9a, 0x9f, 0x21, 0x49, 0x55,
	0x3a, 0x63, 0x94, 0xed, 0x48, 0x25, 0x39, 0x1e, 0xd3, 0x51, 0xfa, 0x77, 0x76, 0xb6, 0x62, 0xfa,
	0xab, 0xce, 0x7c, 0x26, 0xd4, 0xda, 0x6c, 0xf4, 0x98, 0xb6, 0xaa, 0x81, 0x9e, 0x54, 0x62, 0x33,
	0xd0, 0x5b, 0x70, 0x6e, 0x54, 0x8e, 0x44, 0x77, 0x27, 0x55, 0x30, 0x33, 0x78, 0x5e, 0x03, 0x1c,
	0x8a, 0x66, 0x1a, 0x27, 0x64, 0x42, 0x61, 0xcb, 0xc6, 0x3e, 0xd4, 0xc3, 0x34, 0xb0, 0x13, 0xe2,
	0xd9, 0xd8, 0x9d, 0xe4, 0x50, 0x10, 0xd3, 0xdb, 0x49, 0x12, 0x02, 0x5a, 0x76, 0x06, 0x46, 0x35,
	0x2e, 0x8d, 0x0c, 0x1c, 0x21, 0x8b, 0x65, 0xf0, 0xfc, 0x16, 0x50, 0x52, 0xff, 0x42, 0xf7, 0x75,
	0xce, 0xca, 0x74, 0xd1, 0x2c, 0x83, 0x6b, 0x07, 0xce, 0x0e, 0x8b, 0x63, 0x1a, 0x67, 0x72, 0xaa,
	0x9a, 0x96, 0xcd, 0x31, 0x2c, 0x47, 0xa1, 0xdb, 0x9a, 0x99, 0xd7, 0xe7, 0x20, 0x42, 0x0e, 0x4d,
	0x68, 0x3b, 0xe8, 0x8e, 0xce, 0x22, 0x48, 0x11, 0x9d, 0x32, 0xd3, 0x73, 0x21, 0x16, 0xf3, 0x22,
	0x52, 0xeb, 0xee, 0x1d, 0x87, 0x69, 0x48, 0x3a, 0xcb, 0xe0, 0xea, 0xc0, 0xc5, 0x58, 0x54, 0xed,
	0x50, 0xf6, 0x3b, 0x15, 0xb6, 0x37, 0x30, 0x3f, 0xa4, 0x22, 0x69, 0x94, 0x50, 0x9a, 0xea, 0x94,
	0xcd, 0x30, 0xa4, 0x7b, 0x68, 0x7d, 0x71, 0x1c, 0x8b, 0x81, 0x0c, 0x44, 0xbc, 0x48, 0x4b, 0x10,
	0x7a, 0xac, 0xc6, 0x42, 0x48, 0x97, 0x3c, 0xb2, 0xa9, 0x46, 0x44, 0x0e, 0x5d, 0xaa, 0x74, 0x6d,
	0x24, 0x9b, 0x6a, 0x44, 0x21, 0xd1, 0xa5, 0x4a, 0x17, 0x56, 0x32, 0xa8, 0x7e, 0x9f, 0x94, 0x52,
	0x9e, 0x07, 0xb4, 0x89, 0xc3, 0x50, 0xa7, 0x98, 0x52, 0x35, 0x98, 0x8a, 0xe6, 0x47, 0xcf, 0xb0,
	0x28, 0x62, 0x4e, 0xa1, 0x3f, 0x24, 0xb4, 0x8f, 0xa8, 0x2b, 0xb7, 0x35, 0x3f, 0xa3, 0x46, 0x34,
	0x93, 0xca, 0x9d, 0x63, 0xc7, 0xc5, 0x2f, 0x44, 0x09, 0x95, 0x41, 0xaf, 0x0e, 0x53, 0x95, 0x89,
	0xa3, 0x53, 0xb0, 0xfe, 0xe8, 0x1f, 0xef, 0xae, 0xe6, 0xbe, 0x7d, 0x77, 0x35, 0xf7, 0xef, 0x77,
	0x57, 0x73, 0xaf, 0xef, 0xc7, 0x7e, 0x43, 0xf7, 0xc9, 0x01, 0x6e, 0xad, 0xad, 0x2e, 0x4b, 0xce,
	0x65, 0xdb, 0x27, 0xcb, 0x69, 0xbf, 0xe1, 0xfb, 0x2c, 0x7a, 0xde, 0x29, 0x0a, 0xec, 0xd5, 0xff,
	0x05, 0x00, 0x00, 0xff, 0xff, 0xe3, 0x43, 0x64, 0x9d, 0xeb, 0x27, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MachineServiceClient is the client API for MachineService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MachineServiceClient interface {
	Create(ctx context.Context, in *CreateMachineRequest, opts ...grpc.CallOption) (*CreateMachineResponse, error)
	Delete(ctx context.Context, in *DeleteMachineRequest, opts ...grpc.CallOption) (*DeleteMachineResponse, error)
	Get(ctx context.Context, in *GetMachineRequest, opts ...grpc.CallOption) (*GetMachineResponse, error)
	GetEvents(ctx context.Context, in *GetMachineRequest, opts ...grpc.CallOption) (*GetEventsResponse, error)
	Start(ctx context.Context, in *StartMachineRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Stop(ctx context.Context, in *StopMachineRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Restart(ctx context.Context, in *RestartMachineRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Reset(ctx context.Context, in *RestartMachineRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	List(ctx context.Context, in *ListMachinesRequest, opts ...grpc.CallOption) (*ListMachinesResponse, error)
	ListNames(ctx context.Context, in *ListMachinesRequest, opts ...grpc.CallOption) (*ListNamesResponse, error)
	SetMemLimits(ctx context.Context, in *SetMemLimitsRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	SetCPULimits(ctx context.Context, in *SetCPULimitsRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	SetCPUSockets(ctx context.Context, in *SetCPUSocketsRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	SetCPUQuota(ctx context.Context, in *SetCPUQuotaRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	SetCPUModel(ctx context.Context, in *SetCPUModelRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	ActivateVNC(ctx context.Context, in *ActivateVNCRequest, opts ...grpc.CallOption) (*ActivateVNCResponse, error)
	AttachInputDevice(ctx context.Context, in *AttachInputDeviceRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	DetachInputDevice(ctx context.Context, in *DetachInputDeviceRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	AttachCdrom(ctx context.Context, in *AttachCdromRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	DetachCdrom(ctx context.Context, in *DetachCdromRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	ChangeCdromMedia(ctx context.Context, in *ChangeCdromMediaRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	AttachDisk(ctx context.Context, in *AttachDiskRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	DetachDisk(ctx context.Context, in *DetachDiskRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	SetDiskLimits(ctx context.Context, in *SetDiskLimitsRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	RemoveDiskBitmap(ctx context.Context, in *RemoveDiskBitmapRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	ResizeQemuBlockdev(ctx context.Context, in *ResizeQemuBlockdevRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	AttachNetIface(ctx context.Context, in *AttachNetIfaceRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	DetachNetIface(ctx context.Context, in *DetachNetIfaceRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	SetNetIfaceLinkState(ctx context.Context, in *SetNetIfaceLinkRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	SetNetIfaceUpScript(ctx context.Context, in *SetNetIfaceScriptRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	SetNetIfaceDownScript(ctx context.Context, in *SetNetIfaceScriptRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	AttachChannel(ctx context.Context, in *AttachChannelRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	DetachChannel(ctx context.Context, in *DetachChannelRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	AttachCloudInitDrive(ctx context.Context, in *AttachCloudInitRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	DetachCloudInitDrive(ctx context.Context, in *DetachCloudInitRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	ChangeCloudInitDrive(ctx context.Context, in *ChangeCloudInitRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	StartDiskBackupProcess(ctx context.Context, in *StartDiskBackupRequest, opts ...grpc.CallOption) (*StartBackupResponse, error)
	StartMigrationProcess(ctx context.Context, in *StartMigrationRequest, opts ...grpc.CallOption) (*StartMigrationResponse, error)
	SetExternalKernel(ctx context.Context, in *SetExternalKernelRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type machineServiceClient struct {
	cc *grpc.ClientConn
}

func NewMachineServiceClient(cc *grpc.ClientConn) MachineServiceClient {
	return &machineServiceClient{cc}
}

func (c *machineServiceClient) Create(ctx context.Context, in *CreateMachineRequest, opts ...grpc.CallOption) (*CreateMachineResponse, error) {
	out := new(CreateMachineResponse)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) Delete(ctx context.Context, in *DeleteMachineRequest, opts ...grpc.CallOption) (*DeleteMachineResponse, error) {
	out := new(DeleteMachineResponse)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) Get(ctx context.Context, in *GetMachineRequest, opts ...grpc.CallOption) (*GetMachineResponse, error) {
	out := new(GetMachineResponse)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) GetEvents(ctx context.Context, in *GetMachineRequest, opts ...grpc.CallOption) (*GetEventsResponse, error) {
	out := new(GetEventsResponse)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/GetEvents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) Start(ctx context.Context, in *StartMachineRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/Start", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) Stop(ctx context.Context, in *StopMachineRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/Stop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) Restart(ctx context.Context, in *RestartMachineRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/Restart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) Reset(ctx context.Context, in *RestartMachineRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/Reset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) List(ctx context.Context, in *ListMachinesRequest, opts ...grpc.CallOption) (*ListMachinesResponse, error) {
	out := new(ListMachinesResponse)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) ListNames(ctx context.Context, in *ListMachinesRequest, opts ...grpc.CallOption) (*ListNamesResponse, error) {
	out := new(ListNamesResponse)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/ListNames", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) SetMemLimits(ctx context.Context, in *SetMemLimitsRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/SetMemLimits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) SetCPULimits(ctx context.Context, in *SetCPULimitsRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/SetCPULimits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) SetCPUSockets(ctx context.Context, in *SetCPUSocketsRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/SetCPUSockets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) SetCPUQuota(ctx context.Context, in *SetCPUQuotaRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/SetCPUQuota", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) SetCPUModel(ctx context.Context, in *SetCPUModelRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/SetCPUModel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) ActivateVNC(ctx context.Context, in *ActivateVNCRequest, opts ...grpc.CallOption) (*ActivateVNCResponse, error) {
	out := new(ActivateVNCResponse)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/ActivateVNC", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) AttachInputDevice(ctx context.Context, in *AttachInputDeviceRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/AttachInputDevice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) DetachInputDevice(ctx context.Context, in *DetachInputDeviceRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/DetachInputDevice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) AttachCdrom(ctx context.Context, in *AttachCdromRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/AttachCdrom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) DetachCdrom(ctx context.Context, in *DetachCdromRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/DetachCdrom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) ChangeCdromMedia(ctx context.Context, in *ChangeCdromMediaRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/ChangeCdromMedia", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) AttachDisk(ctx context.Context, in *AttachDiskRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/AttachDisk", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) DetachDisk(ctx context.Context, in *DetachDiskRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/DetachDisk", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) SetDiskLimits(ctx context.Context, in *SetDiskLimitsRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/SetDiskLimits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) RemoveDiskBitmap(ctx context.Context, in *RemoveDiskBitmapRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/RemoveDiskBitmap", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) ResizeQemuBlockdev(ctx context.Context, in *ResizeQemuBlockdevRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/ResizeQemuBlockdev", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) AttachNetIface(ctx context.Context, in *AttachNetIfaceRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/AttachNetIface", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) DetachNetIface(ctx context.Context, in *DetachNetIfaceRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/DetachNetIface", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) SetNetIfaceLinkState(ctx context.Context, in *SetNetIfaceLinkRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/SetNetIfaceLinkState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) SetNetIfaceUpScript(ctx context.Context, in *SetNetIfaceScriptRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/SetNetIfaceUpScript", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) SetNetIfaceDownScript(ctx context.Context, in *SetNetIfaceScriptRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/SetNetIfaceDownScript", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) AttachChannel(ctx context.Context, in *AttachChannelRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/AttachChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) DetachChannel(ctx context.Context, in *DetachChannelRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/DetachChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) AttachCloudInitDrive(ctx context.Context, in *AttachCloudInitRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/AttachCloudInitDrive", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) DetachCloudInitDrive(ctx context.Context, in *DetachCloudInitRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/DetachCloudInitDrive", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) ChangeCloudInitDrive(ctx context.Context, in *ChangeCloudInitRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/ChangeCloudInitDrive", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) StartDiskBackupProcess(ctx context.Context, in *StartDiskBackupRequest, opts ...grpc.CallOption) (*StartBackupResponse, error) {
	out := new(StartBackupResponse)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/StartDiskBackupProcess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) StartMigrationProcess(ctx context.Context, in *StartMigrationRequest, opts ...grpc.CallOption) (*StartMigrationResponse, error) {
	out := new(StartMigrationResponse)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/StartMigrationProcess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineServiceClient) SetExternalKernel(ctx context.Context, in *SetExternalKernelRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.machines.v1.MachineService/SetExternalKernel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MachineServiceServer is the server API for MachineService service.
type MachineServiceServer interface {
	Create(context.Context, *CreateMachineRequest) (*CreateMachineResponse, error)
	Delete(context.Context, *DeleteMachineRequest) (*DeleteMachineResponse, error)
	Get(context.Context, *GetMachineRequest) (*GetMachineResponse, error)
	GetEvents(context.Context, *GetMachineRequest) (*GetEventsResponse, error)
	Start(context.Context, *StartMachineRequest) (*empty.Empty, error)
	Stop(context.Context, *StopMachineRequest) (*empty.Empty, error)
	Restart(context.Context, *RestartMachineRequest) (*empty.Empty, error)
	Reset(context.Context, *RestartMachineRequest) (*empty.Empty, error)
	List(context.Context, *ListMachinesRequest) (*ListMachinesResponse, error)
	ListNames(context.Context, *ListMachinesRequest) (*ListNamesResponse, error)
	SetMemLimits(context.Context, *SetMemLimitsRequest) (*empty.Empty, error)
	SetCPULimits(context.Context, *SetCPULimitsRequest) (*empty.Empty, error)
	SetCPUSockets(context.Context, *SetCPUSocketsRequest) (*empty.Empty, error)
	SetCPUQuota(context.Context, *SetCPUQuotaRequest) (*empty.Empty, error)
	SetCPUModel(context.Context, *SetCPUModelRequest) (*empty.Empty, error)
	ActivateVNC(context.Context, *ActivateVNCRequest) (*ActivateVNCResponse, error)
	AttachInputDevice(context.Context, *AttachInputDeviceRequest) (*empty.Empty, error)
	DetachInputDevice(context.Context, *DetachInputDeviceRequest) (*empty.Empty, error)
	AttachCdrom(context.Context, *AttachCdromRequest) (*empty.Empty, error)
	DetachCdrom(context.Context, *DetachCdromRequest) (*empty.Empty, error)
	ChangeCdromMedia(context.Context, *ChangeCdromMediaRequest) (*empty.Empty, error)
	AttachDisk(context.Context, *AttachDiskRequest) (*empty.Empty, error)
	DetachDisk(context.Context, *DetachDiskRequest) (*empty.Empty, error)
	SetDiskLimits(context.Context, *SetDiskLimitsRequest) (*empty.Empty, error)
	RemoveDiskBitmap(context.Context, *RemoveDiskBitmapRequest) (*empty.Empty, error)
	ResizeQemuBlockdev(context.Context, *ResizeQemuBlockdevRequest) (*empty.Empty, error)
	AttachNetIface(context.Context, *AttachNetIfaceRequest) (*empty.Empty, error)
	DetachNetIface(context.Context, *DetachNetIfaceRequest) (*empty.Empty, error)
	SetNetIfaceLinkState(context.Context, *SetNetIfaceLinkRequest) (*empty.Empty, error)
	SetNetIfaceUpScript(context.Context, *SetNetIfaceScriptRequest) (*empty.Empty, error)
	SetNetIfaceDownScript(context.Context, *SetNetIfaceScriptRequest) (*empty.Empty, error)
	AttachChannel(context.Context, *AttachChannelRequest) (*empty.Empty, error)
	DetachChannel(context.Context, *DetachChannelRequest) (*empty.Empty, error)
	AttachCloudInitDrive(context.Context, *AttachCloudInitRequest) (*empty.Empty, error)
	DetachCloudInitDrive(context.Context, *DetachCloudInitRequest) (*empty.Empty, error)
	ChangeCloudInitDrive(context.Context, *ChangeCloudInitRequest) (*empty.Empty, error)
	StartDiskBackupProcess(context.Context, *StartDiskBackupRequest) (*StartBackupResponse, error)
	StartMigrationProcess(context.Context, *StartMigrationRequest) (*StartMigrationResponse, error)
	SetExternalKernel(context.Context, *SetExternalKernelRequest) (*empty.Empty, error)
}

// UnimplementedMachineServiceServer can be embedded to have forward compatible implementations.
type UnimplementedMachineServiceServer struct {
}

func (*UnimplementedMachineServiceServer) Create(ctx context.Context, req *CreateMachineRequest) (*CreateMachineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (*UnimplementedMachineServiceServer) Delete(ctx context.Context, req *DeleteMachineRequest) (*DeleteMachineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (*UnimplementedMachineServiceServer) Get(ctx context.Context, req *GetMachineRequest) (*GetMachineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (*UnimplementedMachineServiceServer) GetEvents(ctx context.Context, req *GetMachineRequest) (*GetEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEvents not implemented")
}
func (*UnimplementedMachineServiceServer) Start(ctx context.Context, req *StartMachineRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Start not implemented")
}
func (*UnimplementedMachineServiceServer) Stop(ctx context.Context, req *StopMachineRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
}
func (*UnimplementedMachineServiceServer) Restart(ctx context.Context, req *RestartMachineRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Restart not implemented")
}
func (*UnimplementedMachineServiceServer) Reset(ctx context.Context, req *RestartMachineRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Reset not implemented")
}
func (*UnimplementedMachineServiceServer) List(ctx context.Context, req *ListMachinesRequest) (*ListMachinesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (*UnimplementedMachineServiceServer) ListNames(ctx context.Context, req *ListMachinesRequest) (*ListNamesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNames not implemented")
}
func (*UnimplementedMachineServiceServer) SetMemLimits(ctx context.Context, req *SetMemLimitsRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMemLimits not implemented")
}
func (*UnimplementedMachineServiceServer) SetCPULimits(ctx context.Context, req *SetCPULimitsRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCPULimits not implemented")
}
func (*UnimplementedMachineServiceServer) SetCPUSockets(ctx context.Context, req *SetCPUSocketsRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCPUSockets not implemented")
}
func (*UnimplementedMachineServiceServer) SetCPUQuota(ctx context.Context, req *SetCPUQuotaRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCPUQuota not implemented")
}
func (*UnimplementedMachineServiceServer) SetCPUModel(ctx context.Context, req *SetCPUModelRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCPUModel not implemented")
}
func (*UnimplementedMachineServiceServer) ActivateVNC(ctx context.Context, req *ActivateVNCRequest) (*ActivateVNCResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivateVNC not implemented")
}
func (*UnimplementedMachineServiceServer) AttachInputDevice(ctx context.Context, req *AttachInputDeviceRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttachInputDevice not implemented")
}
func (*UnimplementedMachineServiceServer) DetachInputDevice(ctx context.Context, req *DetachInputDeviceRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetachInputDevice not implemented")
}
func (*UnimplementedMachineServiceServer) AttachCdrom(ctx context.Context, req *AttachCdromRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttachCdrom not implemented")
}
func (*UnimplementedMachineServiceServer) DetachCdrom(ctx context.Context, req *DetachCdromRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetachCdrom not implemented")
}
func (*UnimplementedMachineServiceServer) ChangeCdromMedia(ctx context.Context, req *ChangeCdromMediaRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeCdromMedia not implemented")
}
func (*UnimplementedMachineServiceServer) AttachDisk(ctx context.Context, req *AttachDiskRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttachDisk not implemented")
}
func (*UnimplementedMachineServiceServer) DetachDisk(ctx context.Context, req *DetachDiskRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetachDisk not implemented")
}
func (*UnimplementedMachineServiceServer) SetDiskLimits(ctx context.Context, req *SetDiskLimitsRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDiskLimits not implemented")
}
func (*UnimplementedMachineServiceServer) RemoveDiskBitmap(ctx context.Context, req *RemoveDiskBitmapRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveDiskBitmap not implemented")
}
func (*UnimplementedMachineServiceServer) ResizeQemuBlockdev(ctx context.Context, req *ResizeQemuBlockdevRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResizeQemuBlockdev not implemented")
}
func (*UnimplementedMachineServiceServer) AttachNetIface(ctx context.Context, req *AttachNetIfaceRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttachNetIface not implemented")
}
func (*UnimplementedMachineServiceServer) DetachNetIface(ctx context.Context, req *DetachNetIfaceRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetachNetIface not implemented")
}
func (*UnimplementedMachineServiceServer) SetNetIfaceLinkState(ctx context.Context, req *SetNetIfaceLinkRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetNetIfaceLinkState not implemented")
}
func (*UnimplementedMachineServiceServer) SetNetIfaceUpScript(ctx context.Context, req *SetNetIfaceScriptRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetNetIfaceUpScript not implemented")
}
func (*UnimplementedMachineServiceServer) SetNetIfaceDownScript(ctx context.Context, req *SetNetIfaceScriptRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetNetIfaceDownScript not implemented")
}
func (*UnimplementedMachineServiceServer) AttachChannel(ctx context.Context, req *AttachChannelRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttachChannel not implemented")
}
func (*UnimplementedMachineServiceServer) DetachChannel(ctx context.Context, req *DetachChannelRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetachChannel not implemented")
}
func (*UnimplementedMachineServiceServer) AttachCloudInitDrive(ctx context.Context, req *AttachCloudInitRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttachCloudInitDrive not implemented")
}
func (*UnimplementedMachineServiceServer) DetachCloudInitDrive(ctx context.Context, req *DetachCloudInitRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetachCloudInitDrive not implemented")
}
func (*UnimplementedMachineServiceServer) ChangeCloudInitDrive(ctx context.Context, req *ChangeCloudInitRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeCloudInitDrive not implemented")
}
func (*UnimplementedMachineServiceServer) StartDiskBackupProcess(ctx context.Context, req *StartDiskBackupRequest) (*StartBackupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartDiskBackupProcess not implemented")
}
func (*UnimplementedMachineServiceServer) StartMigrationProcess(ctx context.Context, req *StartMigrationRequest) (*StartMigrationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartMigrationProcess not implemented")
}
func (*UnimplementedMachineServiceServer) SetExternalKernel(ctx context.Context, req *SetExternalKernelRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetExternalKernel not implemented")
}

func RegisterMachineServiceServer(s *grpc.Server, srv MachineServiceServer) {
	s.RegisterService(&_MachineService_serviceDesc, srv)
}

func _MachineService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMachineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).Create(ctx, req.(*CreateMachineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMachineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).Delete(ctx, req.(*DeleteMachineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMachineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).Get(ctx, req.(*GetMachineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_GetEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMachineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).GetEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/GetEvents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).GetEvents(ctx, req.(*GetMachineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartMachineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).Start(ctx, req.(*StartMachineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopMachineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).Stop(ctx, req.(*StopMachineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_Restart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestartMachineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).Restart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/Restart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).Restart(ctx, req.(*RestartMachineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_Reset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestartMachineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).Reset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/Reset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).Reset(ctx, req.(*RestartMachineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMachinesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).List(ctx, req.(*ListMachinesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_ListNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMachinesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).ListNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/ListNames",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).ListNames(ctx, req.(*ListMachinesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_SetMemLimits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetMemLimitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).SetMemLimits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/SetMemLimits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).SetMemLimits(ctx, req.(*SetMemLimitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_SetCPULimits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetCPULimitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).SetCPULimits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/SetCPULimits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).SetCPULimits(ctx, req.(*SetCPULimitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_SetCPUSockets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetCPUSocketsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).SetCPUSockets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/SetCPUSockets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).SetCPUSockets(ctx, req.(*SetCPUSocketsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_SetCPUQuota_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetCPUQuotaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).SetCPUQuota(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/SetCPUQuota",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).SetCPUQuota(ctx, req.(*SetCPUQuotaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_SetCPUModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetCPUModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).SetCPUModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/SetCPUModel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).SetCPUModel(ctx, req.(*SetCPUModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_ActivateVNC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActivateVNCRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).ActivateVNC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/ActivateVNC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).ActivateVNC(ctx, req.(*ActivateVNCRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_AttachInputDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachInputDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).AttachInputDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/AttachInputDevice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).AttachInputDevice(ctx, req.(*AttachInputDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_DetachInputDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachInputDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).DetachInputDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/DetachInputDevice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).DetachInputDevice(ctx, req.(*DetachInputDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_AttachCdrom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachCdromRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).AttachCdrom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/AttachCdrom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).AttachCdrom(ctx, req.(*AttachCdromRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_DetachCdrom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachCdromRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).DetachCdrom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/DetachCdrom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).DetachCdrom(ctx, req.(*DetachCdromRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_ChangeCdromMedia_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeCdromMediaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).ChangeCdromMedia(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/ChangeCdromMedia",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).ChangeCdromMedia(ctx, req.(*ChangeCdromMediaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_AttachDisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).AttachDisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/AttachDisk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).AttachDisk(ctx, req.(*AttachDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_DetachDisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).DetachDisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/DetachDisk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).DetachDisk(ctx, req.(*DetachDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_SetDiskLimits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDiskLimitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).SetDiskLimits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/SetDiskLimits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).SetDiskLimits(ctx, req.(*SetDiskLimitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_RemoveDiskBitmap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveDiskBitmapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).RemoveDiskBitmap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/RemoveDiskBitmap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).RemoveDiskBitmap(ctx, req.(*RemoveDiskBitmapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_ResizeQemuBlockdev_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResizeQemuBlockdevRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).ResizeQemuBlockdev(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/ResizeQemuBlockdev",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).ResizeQemuBlockdev(ctx, req.(*ResizeQemuBlockdevRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_AttachNetIface_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachNetIfaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).AttachNetIface(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/AttachNetIface",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).AttachNetIface(ctx, req.(*AttachNetIfaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_DetachNetIface_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachNetIfaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).DetachNetIface(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/DetachNetIface",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).DetachNetIface(ctx, req.(*DetachNetIfaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_SetNetIfaceLinkState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetNetIfaceLinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).SetNetIfaceLinkState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/SetNetIfaceLinkState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).SetNetIfaceLinkState(ctx, req.(*SetNetIfaceLinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_SetNetIfaceUpScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetNetIfaceScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).SetNetIfaceUpScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/SetNetIfaceUpScript",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).SetNetIfaceUpScript(ctx, req.(*SetNetIfaceScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_SetNetIfaceDownScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetNetIfaceScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).SetNetIfaceDownScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/SetNetIfaceDownScript",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).SetNetIfaceDownScript(ctx, req.(*SetNetIfaceScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_AttachChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).AttachChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/AttachChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).AttachChannel(ctx, req.(*AttachChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_DetachChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).DetachChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/DetachChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).DetachChannel(ctx, req.(*DetachChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_AttachCloudInitDrive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachCloudInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).AttachCloudInitDrive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/AttachCloudInitDrive",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).AttachCloudInitDrive(ctx, req.(*AttachCloudInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_DetachCloudInitDrive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachCloudInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).DetachCloudInitDrive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/DetachCloudInitDrive",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).DetachCloudInitDrive(ctx, req.(*DetachCloudInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_ChangeCloudInitDrive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeCloudInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).ChangeCloudInitDrive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/ChangeCloudInitDrive",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).ChangeCloudInitDrive(ctx, req.(*ChangeCloudInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_StartDiskBackupProcess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartDiskBackupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).StartDiskBackupProcess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/StartDiskBackupProcess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).StartDiskBackupProcess(ctx, req.(*StartDiskBackupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_StartMigrationProcess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartMigrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).StartMigrationProcess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/StartMigrationProcess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).StartMigrationProcess(ctx, req.(*StartMigrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineService_SetExternalKernel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetExternalKernelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineServiceServer).SetExternalKernel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.machines.v1.MachineService/SetExternalKernel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineServiceServer).SetExternalKernel(ctx, req.(*SetExternalKernelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _MachineService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kvmrun.api.services.machines.v1.MachineService",
	HandlerType: (*MachineServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _MachineService_Create_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _MachineService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _MachineService_Get_Handler,
		},
		{
			MethodName: "GetEvents",
			Handler:    _MachineService_GetEvents_Handler,
		},
		{
			MethodName: "Start",
			Handler:    _MachineService_Start_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _MachineService_Stop_Handler,
		},
		{
			MethodName: "Restart",
			Handler:    _MachineService_Restart_Handler,
		},
		{
			MethodName: "Reset",
			Handler:    _MachineService_Reset_Handler,
		},
		{
			MethodName: "List",
			Handler:    _MachineService_List_Handler,
		},
		{
			MethodName: "ListNames",
			Handler:    _MachineService_ListNames_Handler,
		},
		{
			MethodName: "SetMemLimits",
			Handler:    _MachineService_SetMemLimits_Handler,
		},
		{
			MethodName: "SetCPULimits",
			Handler:    _MachineService_SetCPULimits_Handler,
		},
		{
			MethodName: "SetCPUSockets",
			Handler:    _MachineService_SetCPUSockets_Handler,
		},
		{
			MethodName: "SetCPUQuota",
			Handler:    _MachineService_SetCPUQuota_Handler,
		},
		{
			MethodName: "SetCPUModel",
			Handler:    _MachineService_SetCPUModel_Handler,
		},
		{
			MethodName: "ActivateVNC",
			Handler:    _MachineService_ActivateVNC_Handler,
		},
		{
			MethodName: "AttachInputDevice",
			Handler:    _MachineService_AttachInputDevice_Handler,
		},
		{
			MethodName: "DetachInputDevice",
			Handler:    _MachineService_DetachInputDevice_Handler,
		},
		{
			MethodName: "AttachCdrom",
			Handler:    _MachineService_AttachCdrom_Handler,
		},
		{
			MethodName: "DetachCdrom",
			Handler:    _MachineService_DetachCdrom_Handler,
		},
		{
			MethodName: "ChangeCdromMedia",
			Handler:    _MachineService_ChangeCdromMedia_Handler,
		},
		{
			MethodName: "AttachDisk",
			Handler:    _MachineService_AttachDisk_Handler,
		},
		{
			MethodName: "DetachDisk",
			Handler:    _MachineService_DetachDisk_Handler,
		},
		{
			MethodName: "SetDiskLimits",
			Handler:    _MachineService_SetDiskLimits_Handler,
		},
		{
			MethodName: "RemoveDiskBitmap",
			Handler:    _MachineService_RemoveDiskBitmap_Handler,
		},
		{
			MethodName: "ResizeQemuBlockdev",
			Handler:    _MachineService_ResizeQemuBlockdev_Handler,
		},
		{
			MethodName: "AttachNetIface",
			Handler:    _MachineService_AttachNetIface_Handler,
		},
		{
			MethodName: "DetachNetIface",
			Handler:    _MachineService_DetachNetIface_Handler,
		},
		{
			MethodName: "SetNetIfaceLinkState",
			Handler:    _MachineService_SetNetIfaceLinkState_Handler,
		},
		{
			MethodName: "SetNetIfaceUpScript",
			Handler:    _MachineService_SetNetIfaceUpScript_Handler,
		},
		{
			MethodName: "SetNetIfaceDownScript",
			Handler:    _MachineService_SetNetIfaceDownScript_Handler,
		},
		{
			MethodName: "AttachChannel",
			Handler:    _MachineService_AttachChannel_Handler,
		},
		{
			MethodName: "DetachChannel",
			Handler:    _MachineService_DetachChannel_Handler,
		},
		{
			MethodName: "AttachCloudInitDrive",
			Handler:    _MachineService_AttachCloudInitDrive_Handler,
		},
		{
			MethodName: "DetachCloudInitDrive",
			Handler:    _MachineService_DetachCloudInitDrive_Handler,
		},
		{
			MethodName: "ChangeCloudInitDrive",
			Handler:    _MachineService_ChangeCloudInitDrive_Handler,
		},
		{
			MethodName: "StartDiskBackupProcess",
			Handler:    _MachineService_StartDiskBackupProcess_Handler,
		},
		{
			MethodName: "StartMigrationProcess",
			Handler:    _MachineService_StartMigrationProcess_Handler,
		},
		{
			MethodName: "SetExternalKernel",
			Handler:    _MachineService_SetExternalKernel_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services/machines/v1/machines.proto",
}

func (m *CreateMachineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateMachineRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateMachineRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ExtraFiles) > 0 {
		for k := range m.ExtraFiles {
			v := m.ExtraFiles[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintMachines(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMachines(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMachines(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Persistent {
		i--
		if m.Persistent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMachines(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateMachineResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateMachineResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateMachineResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Machine != nil {
		{
			size, err := m.Machine.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMachines(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteMachineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteMachineRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteMachineRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Force {
		i--
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteMachineResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteMachineResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteMachineResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Machine != nil {
		{
			size, err := m.Machine.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMachines(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetMachineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMachineRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMachineRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetMachineResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMachineResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMachineResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Machine != nil {
		{
			size, err := m.Machine.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMachines(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetEventsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetEventsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetEventsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMachines(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StartMachineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartMachineRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartMachineRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WaitInterval != 0 {
		i = encodeVarintMachines(dAtA, i, uint64(m.WaitInterval))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StopMachineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopMachineRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StopMachineRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Force {
		i--
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Wait {
		i--
		if m.Wait {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RestartMachineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestartMachineRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RestartMachineRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Wait {
		i--
		if m.Wait {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListMachinesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListMachinesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListMachinesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Names) > 0 {
		for iNdEx := len(m.Names) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Names[iNdEx])
			copy(dAtA[i:], m.Names[iNdEx])
			i = encodeVarintMachines(dAtA, i, uint64(len(m.Names[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListMachinesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListMachinesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListMachinesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Machines) > 0 {
		for iNdEx := len(m.Machines) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Machines[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMachines(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListNamesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListNamesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListNamesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Machines) > 0 {
		for iNdEx := len(m.Machines) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Machines[iNdEx])
			copy(dAtA[i:], m.Machines[iNdEx])
			i = encodeVarintMachines(dAtA, i, uint64(len(m.Machines[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SetMemLimitsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetMemLimitsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetMemLimitsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Live {
		i--
		if m.Live {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Total != 0 {
		i = encodeVarintMachines(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x18
	}
	if m.Actual != 0 {
		i = encodeVarintMachines(dAtA, i, uint64(m.Actual))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetCPULimitsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetCPULimitsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetCPULimitsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Live {
		i--
		if m.Live {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Total != 0 {
		i = encodeVarintMachines(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x18
	}
	if m.Actual != 0 {
		i = encodeVarintMachines(dAtA, i, uint64(m.Actual))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetCPUSocketsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetCPUSocketsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetCPUSocketsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Sockets != 0 {
		i = encodeVarintMachines(dAtA, i, uint64(m.Sockets))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetCPUQuotaRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetCPUQuotaRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetCPUQuotaRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Live {
		i--
		if m.Live {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Quota != 0 {
		i = encodeVarintMachines(dAtA, i, uint64(m.Quota))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetCPUModelRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetCPUModelRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetCPUModelRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Model) > 0 {
		i -= len(m.Model)
		copy(dAtA[i:], m.Model)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Model)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActivateVNCRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivateVNCRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActivateVNCRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActivateVNCResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivateVNCResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActivateVNCResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Requisites != nil {
		{
			size, err := m.Requisites.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMachines(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AttachInputDeviceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttachInputDeviceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttachInputDeviceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintMachines(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DetachInputDeviceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DetachInputDeviceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DetachInputDeviceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintMachines(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AttachCdromRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttachCdromRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttachCdromRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Live {
		i--
		if m.Live {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.ProxyEnvs) > 0 {
		for k := range m.ProxyEnvs {
			v := m.ProxyEnvs[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintMachines(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMachines(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMachines(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.ProxyCommand) > 0 {
		i -= len(m.ProxyCommand)
		copy(dAtA[i:], m.ProxyCommand)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.ProxyCommand)))
		i--
		dAtA[i] = 0x42
	}
	if m.Bootindex != 0 {
		i = encodeVarintMachines(dAtA, i, uint64(m.Bootindex))
		i--
		dAtA[i] = 0x38
	}
	if m.Index != 0 {
		i = encodeVarintMachines(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x30
	}
	if m.ReadOnly {
		i--
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Driver != 0 {
		i = encodeVarintMachines(dAtA, i, uint64(m.Driver))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DeviceMedia) > 0 {
		i -= len(m.DeviceMedia)
		copy(dAtA[i:], m.DeviceMedia)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.DeviceMedia)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DeviceName) > 0 {
		i -= len(m.DeviceName)
		copy(dAtA[i:], m.DeviceName)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.DeviceName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DetachCdromRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DetachCdromRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DetachCdromRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Live {
		i--
		if m.Live {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.DeviceName) > 0 {
		i -= len(m.DeviceName)
		copy(dAtA[i:], m.DeviceName)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.DeviceName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChangeCdromMediaRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeCdromMediaRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangeCdromMediaRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Live {
		i--
		if m.Live {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.ProxyEnvs) > 0 {
		for k := range m.ProxyEnvs {
			v := m.ProxyEnvs[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintMachines(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMachines(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMachines(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ProxyCommand) > 0 {
		i -= len(m.ProxyCommand)
		copy(dAtA[i:], m.ProxyCommand)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.ProxyCommand)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DeviceMedia) > 0 {
		i -= len(m.DeviceMedia)
		copy(dAtA[i:], m.DeviceMedia)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.DeviceMedia)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DeviceName) > 0 {
		i -= len(m.DeviceName)
		copy(dAtA[i:], m.DeviceName)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.DeviceName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AttachDiskRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttachDiskRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttachDiskRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Live {
		i--
		if m.Live {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.ProxyEnvs) > 0 {
		for k := range m.ProxyEnvs {
			v := m.ProxyEnvs[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintMachines(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintMachines(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintMachines(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.ProxyCommand) > 0 {
		i -= len(m.ProxyCommand)
		copy(dAtA[i:], m.ProxyCommand)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.ProxyCommand)))
		i--
		dAtA[i] = 0x42
	}
	if m.Bootindex != 0 {
		i = encodeVarintMachines(dAtA, i, uint64(m.Bootindex))
		i--
		dAtA[i] = 0x38
	}
	if m.Index != 0 {
		i = encodeVarintMachines(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x30
	}
	if m.IopsWr != 0 {
		i = encodeVarintMachines(dAtA, i, uint64(m.IopsWr))
		i--
		dAtA[i] = 0x28
	}
	if m.IopsRd != 0 {
		i = encodeVarintMachines(dAtA, i, uint64(m.IopsRd))
		i--
		dAtA[i] = 0x20
	}
	if m.Driver != 0 {
		i = encodeVarintMachines(dAtA, i, uint64(m.Driver))
		i--
		dAtA[i] = 0x18
	}
	if len(m.DiskPath) > 0 {
		i -= len(m.DiskPath)
		copy(dAtA[i:], m.DiskPath)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.DiskPath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DetachDiskRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DetachDiskRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DetachDiskRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Live {
		i--
		if m.Live {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.DiskName) > 0 {
		i -= len(m.DiskName)
		copy(dAtA[i:], m.DiskName)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.DiskName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetDiskLimitsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetDiskLimitsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetDiskLimitsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Live {
		i--
		if m.Live {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.IopsWr != 0 {
		i = encodeVarintMachines(dAtA, i, uint64(m.IopsWr))
		i--
		dAtA[i] = 0x20
	}
	if m.IopsRd != 0 {
		i = encodeVarintMachines(dAtA, i, uint64(m.IopsRd))
		i--
		dAtA[i] = 0x18
	}
	if len(m.DiskName) > 0 {
		i -= len(m.DiskName)
		copy(dAtA[i:], m.DiskName)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.DiskName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemoveDiskBitmapRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveDiskBitmapRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveDiskBitmapRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DiskName) > 0 {
		i -= len(m.DiskName)
		copy(dAtA[i:], m.DiskName)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.DiskName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResizeQemuBlockdevRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResizeQemuBlockdevRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResizeQemuBlockdevRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DiskName) > 0 {
		i -= len(m.DiskName)
		copy(dAtA[i:], m.DiskName)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.DiskName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AttachNetIfaceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttachNetIfaceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttachNetIfaceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Live {
		i--
		if m.Live {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.IfdownScript) > 0 {
		i -= len(m.IfdownScript)
		copy(dAtA[i:], m.IfdownScript)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.IfdownScript)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.IfupScript) > 0 {
		i -= len(m.IfupScript)
		copy(dAtA[i:], m.IfupScript)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.IfupScript)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.HwAddr) > 0 {
		i -= len(m.HwAddr)
		copy(dAtA[i:], m.HwAddr)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.HwAddr)))
		i--
		dAtA[i] = 0x22
	}
	if m.Driver != 0 {
		i = encodeVarintMachines(dAtA, i, uint64(m.Driver))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Ifname) > 0 {
		i -= len(m.Ifname)
		copy(dAtA[i:], m.Ifname)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Ifname)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DetachNetIfaceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DetachNetIfaceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DetachNetIfaceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Live {
		i--
		if m.Live {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Ifname) > 0 {
		i -= len(m.Ifname)
		copy(dAtA[i:], m.Ifname)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Ifname)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetNetIfaceScriptRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetNetIfaceScriptRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetNetIfaceScriptRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Ifname) > 0 {
		i -= len(m.Ifname)
		copy(dAtA[i:], m.Ifname)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Ifname)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetNetIfaceLinkRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetNetIfaceLinkRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetNetIfaceLinkRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != 0 {
		i = encodeVarintMachines(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Ifname) > 0 {
		i -= len(m.Ifname)
		copy(dAtA[i:], m.Ifname)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Ifname)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AttachChannelRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttachChannelRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttachChannelRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Live {
		i--
		if m.Live {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Channel != nil {
		{
			size := m.Channel.Size()
			i -= size
			if _, err := m.Channel.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AttachChannelRequest_Vsock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttachChannelRequest_Vsock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Vsock != nil {
		{
			size, err := m.Vsock.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMachines(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AttachChannelRequest_SerialPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttachChannelRequest_SerialPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SerialPort != nil {
		{
			size, err := m.SerialPort.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMachines(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AttachChannelRequest_VirtioVSock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttachChannelRequest_VirtioVSock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttachChannelRequest_VirtioVSock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ContextID != 0 {
		i = encodeVarintMachines(dAtA, i, uint64(m.ContextID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AttachChannelRequest_VirtioSerialPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttachChannelRequest_VirtioSerialPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttachChannelRequest_VirtioSerialPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PortGuestName) > 0 {
		i -= len(m.PortGuestName)
		copy(dAtA[i:], m.PortGuestName)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.PortGuestName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PortID) > 0 {
		i -= len(m.PortID)
		copy(dAtA[i:], m.PortID)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.PortID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DetachChannelRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DetachChannelRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DetachChannelRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Live {
		i--
		if m.Live {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa0
	}
	if m.Channel != nil {
		{
			size := m.Channel.Size()
			i -= size
			if _, err := m.Channel.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DetachChannelRequest_Vsock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DetachChannelRequest_Vsock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Vsock != nil {
		{
			size, err := m.Vsock.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMachines(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *DetachChannelRequest_SerialPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DetachChannelRequest_SerialPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SerialPort != nil {
		{
			size, err := m.SerialPort.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMachines(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DetachChannelRequest_VirtioVSock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DetachChannelRequest_VirtioVSock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DetachChannelRequest_VirtioVSock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DetachChannelRequest_VirtioSerialPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DetachChannelRequest_VirtioSerialPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DetachChannelRequest_VirtioSerialPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PortID) > 0 {
		i -= len(m.PortID)
		copy(dAtA[i:], m.PortID)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.PortID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AttachCloudInitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttachCloudInitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttachCloudInitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DetachCloudInitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DetachCloudInitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DetachCloudInitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChangeCloudInitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeCloudInitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangeCloudInitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StartDiskBackupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartDiskBackupRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartDiskBackupRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ClearBitmap {
		i--
		if m.ClearBitmap {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Incremental {
		i--
		if m.Incremental {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Target) > 0 {
		i -= len(m.Target)
		copy(dAtA[i:], m.Target)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Target)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DiskName) > 0 {
		i -= len(m.DiskName)
		copy(dAtA[i:], m.DiskName)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.DiskName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StartBackupResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartBackupResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartBackupResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TaskKey) > 0 {
		i -= len(m.TaskKey)
		copy(dAtA[i:], m.TaskKey)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.TaskKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StartMigrationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartMigrationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartMigrationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RemoveAfter {
		i--
		if m.RemoveAfter {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.CreateDisks {
		i--
		if m.CreateDisks {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Overrides != nil {
		{
			size, err := m.Overrides.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMachines(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Disks) > 0 {
		for iNdEx := len(m.Disks) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Disks[iNdEx])
			copy(dAtA[i:], m.Disks[iNdEx])
			i = encodeVarintMachines(dAtA, i, uint64(len(m.Disks[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.DstServer) > 0 {
		i -= len(m.DstServer)
		copy(dAtA[i:], m.DstServer)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.DstServer)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StartMigrationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartMigrationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartMigrationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TaskKey) > 0 {
		i -= len(m.TaskKey)
		copy(dAtA[i:], m.TaskKey)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.TaskKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetExternalKernelRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetExternalKernelRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetExternalKernelRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RemoveConf {
		i--
		if m.RemoveConf {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Modiso) > 0 {
		i -= len(m.Modiso)
		copy(dAtA[i:], m.Modiso)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Modiso)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Cmdline) > 0 {
		i -= len(m.Cmdline)
		copy(dAtA[i:], m.Cmdline)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Cmdline)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Initrd) > 0 {
		i -= len(m.Initrd)
		copy(dAtA[i:], m.Initrd)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Initrd)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMachines(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMachines(dAtA []byte, offset int, v uint64) int {
	offset -= sovMachines(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CreateMachineRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.Persistent {
		n += 2
	}
	if len(m.ExtraFiles) > 0 {
		for k, v := range m.ExtraFiles {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovMachines(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovMachines(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovMachines(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateMachineResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Machine != nil {
		l = m.Machine.Size()
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteMachineRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.Force {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteMachineResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Machine != nil {
		l = m.Machine.Size()
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetMachineRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetMachineResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Machine != nil {
		l = m.Machine.Size()
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetEventsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovMachines(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StartMachineRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.WaitInterval != 0 {
		n += 1 + sovMachines(uint64(m.WaitInterval))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StopMachineRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.Wait {
		n += 2
	}
	if m.Force {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RestartMachineRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.Wait {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListMachinesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovMachines(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListMachinesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Machines) > 0 {
		for _, e := range m.Machines {
			l = e.Size()
			n += 1 + l + sovMachines(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListNamesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Machines) > 0 {
		for _, s := range m.Machines {
			l = len(s)
			n += 1 + l + sovMachines(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetMemLimitsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.Actual != 0 {
		n += 1 + sovMachines(uint64(m.Actual))
	}
	if m.Total != 0 {
		n += 1 + sovMachines(uint64(m.Total))
	}
	if m.Live {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetCPULimitsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.Actual != 0 {
		n += 1 + sovMachines(uint64(m.Actual))
	}
	if m.Total != 0 {
		n += 1 + sovMachines(uint64(m.Total))
	}
	if m.Live {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetCPUSocketsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.Sockets != 0 {
		n += 1 + sovMachines(uint64(m.Sockets))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetCPUQuotaRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.Quota != 0 {
		n += 1 + sovMachines(uint64(m.Quota))
	}
	if m.Live {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetCPUModelRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActivateVNCRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActivateVNCResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Requisites != nil {
		l = m.Requisites.Size()
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttachInputDeviceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovMachines(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DetachInputDeviceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovMachines(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttachCdromRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.DeviceMedia)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.Driver != 0 {
		n += 1 + sovMachines(uint64(m.Driver))
	}
	if m.ReadOnly {
		n += 2
	}
	if m.Index != 0 {
		n += 1 + sovMachines(uint64(m.Index))
	}
	if m.Bootindex != 0 {
		n += 1 + sovMachines(uint64(m.Bootindex))
	}
	l = len(m.ProxyCommand)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if len(m.ProxyEnvs) > 0 {
		for k, v := range m.ProxyEnvs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMachines(uint64(len(k))) + 1 + len(v) + sovMachines(uint64(len(v)))
			n += mapEntrySize + 1 + sovMachines(uint64(mapEntrySize))
		}
	}
	if m.Live {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DetachCdromRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.Live {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChangeCdromMediaRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.DeviceMedia)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.ProxyCommand)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if len(m.ProxyEnvs) > 0 {
		for k, v := range m.ProxyEnvs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMachines(uint64(len(k))) + 1 + len(v) + sovMachines(uint64(len(v)))
			n += mapEntrySize + 1 + sovMachines(uint64(mapEntrySize))
		}
	}
	if m.Live {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttachDiskRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.DiskPath)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.Driver != 0 {
		n += 1 + sovMachines(uint64(m.Driver))
	}
	if m.IopsRd != 0 {
		n += 1 + sovMachines(uint64(m.IopsRd))
	}
	if m.IopsWr != 0 {
		n += 1 + sovMachines(uint64(m.IopsWr))
	}
	if m.Index != 0 {
		n += 1 + sovMachines(uint64(m.Index))
	}
	if m.Bootindex != 0 {
		n += 1 + sovMachines(uint64(m.Bootindex))
	}
	l = len(m.ProxyCommand)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if len(m.ProxyEnvs) > 0 {
		for k, v := range m.ProxyEnvs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMachines(uint64(len(k))) + 1 + len(v) + sovMachines(uint64(len(v)))
			n += mapEntrySize + 1 + sovMachines(uint64(mapEntrySize))
		}
	}
	if m.Live {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DetachDiskRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.DiskName)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.Live {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetDiskLimitsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.DiskName)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.IopsRd != 0 {
		n += 1 + sovMachines(uint64(m.IopsRd))
	}
	if m.IopsWr != 0 {
		n += 1 + sovMachines(uint64(m.IopsWr))
	}
	if m.Live {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoveDiskBitmapRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.DiskName)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResizeQemuBlockdevRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.DiskName)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttachNetIfaceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.Ifname)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.Driver != 0 {
		n += 1 + sovMachines(uint64(m.Driver))
	}
	l = len(m.HwAddr)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.IfupScript)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.IfdownScript)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.Live {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DetachNetIfaceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.Ifname)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.Live {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetNetIfaceScriptRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.Ifname)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetNetIfaceLinkRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.Ifname)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovMachines(uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttachChannelRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.Channel != nil {
		n += m.Channel.Size()
	}
	if m.Live {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttachChannelRequest_Vsock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Vsock != nil {
		l = m.Vsock.Size()
		n += 1 + l + sovMachines(uint64(l))
	}
	return n
}
func (m *AttachChannelRequest_SerialPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SerialPort != nil {
		l = m.SerialPort.Size()
		n += 1 + l + sovMachines(uint64(l))
	}
	return n
}
func (m *AttachChannelRequest_VirtioVSock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContextID != 0 {
		n += 1 + sovMachines(uint64(m.ContextID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttachChannelRequest_VirtioSerialPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PortID)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.PortGuestName)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DetachChannelRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.Channel != nil {
		n += m.Channel.Size()
	}
	if m.Live {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DetachChannelRequest_Vsock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Vsock != nil {
		l = m.Vsock.Size()
		n += 1 + l + sovMachines(uint64(l))
	}
	return n
}
func (m *DetachChannelRequest_SerialPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SerialPort != nil {
		l = m.SerialPort.Size()
		n += 1 + l + sovMachines(uint64(l))
	}
	return n
}
func (m *DetachChannelRequest_VirtioVSock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DetachChannelRequest_VirtioSerialPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PortID)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttachCloudInitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DetachCloudInitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChangeCloudInitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StartDiskBackupRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.DiskName)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.Incremental {
		n += 2
	}
	if m.ClearBitmap {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StartBackupResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TaskKey)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StartMigrationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.DstServer)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if len(m.Disks) > 0 {
		for _, s := range m.Disks {
			l = len(s)
			n += 1 + l + sovMachines(uint64(l))
		}
	}
	if m.Overrides != nil {
		l = m.Overrides.Size()
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.CreateDisks {
		n += 2
	}
	if m.RemoveAfter {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StartMigrationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TaskKey)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetExternalKernelRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.Initrd)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.Cmdline)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	l = len(m.Modiso)
	if l > 0 {
		n += 1 + l + sovMachines(uint64(l))
	}
	if m.RemoveConf {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMachines(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMachines(x uint64) (n int) {
	return sovMachines(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CreateMachineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateMachineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateMachineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &types.MachineOpts{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Persistent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Persistent = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraFiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtraFiles == nil {
				m.ExtraFiles = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMachines
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMachines
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMachines
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMachines
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMachines
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthMachines
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthMachines
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMachines(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMachines
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ExtraFiles[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateMachineResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateMachineResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateMachineResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Machine", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Machine == nil {
				m.Machine = &types.Machine{}
			}
			if err := m.Machine.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteMachineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteMachineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteMachineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteMachineResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteMachineResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteMachineResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Machine", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Machine == nil {
				m.Machine = &types.Machine{}
			}
			if err := m.Machine.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMachineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMachineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMachineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMachineResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMachineResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMachineResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Machine", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Machine == nil {
				m.Machine = &types.Machine{}
			}
			if err := m.Machine.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetEventsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetEventsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetEventsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &types.MachineEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartMachineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartMachineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartMachineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitInterval", wireType)
			}
			m.WaitInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitInterval |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopMachineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopMachineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopMachineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Wait = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestartMachineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestartMachineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestartMachineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Wait = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListMachinesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListMachinesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListMachinesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListMachinesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListMachinesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListMachinesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Machines", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Machines = append(m.Machines, &types.Machine{})
			if err := m.Machines[len(m.Machines)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListNamesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListNamesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListNamesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Machines", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Machines = append(m.Machines, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetMemLimitsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetMemLimitsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetMemLimitsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actual", wireType)
			}
			m.Actual = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Actual |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Live", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Live = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetCPULimitsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetCPULimitsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetCPULimitsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actual", wireType)
			}
			m.Actual = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Actual |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Live", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Live = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetCPUSocketsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetCPUSocketsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetCPUSocketsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sockets", wireType)
			}
			m.Sockets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sockets |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetCPUQuotaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetCPUQuotaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetCPUQuotaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quota", wireType)
			}
			m.Quota = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quota |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Live", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Live = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetCPUModelRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetCPUModelRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetCPUModelRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivateVNCRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivateVNCRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivateVNCRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivateVNCResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivateVNCResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivateVNCResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requisites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Requisites == nil {
				m.Requisites = &types.VNCRequisites{}
			}
			if err := m.Requisites.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttachInputDeviceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttachInputDeviceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttachInputDeviceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= types.InputDeviceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DetachInputDeviceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DetachInputDeviceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DetachInputDeviceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= types.InputDeviceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttachCdromRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttachCdromRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttachCdromRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceMedia", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceMedia = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			m.Driver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Driver |= types.CdromDriver(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bootindex", wireType)
			}
			m.Bootindex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bootindex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyCommand", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyCommand = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyEnvs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProxyEnvs == nil {
				m.ProxyEnvs = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMachines
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMachines
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMachines
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMachines
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMachines
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMachines
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthMachines
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMachines(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMachines
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ProxyEnvs[mapkey] = mapvalue
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Live", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Live = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DetachCdromRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DetachCdromRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DetachCdromRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Live", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Live = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeCdromMediaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeCdromMediaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeCdromMediaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceMedia", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceMedia = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyCommand", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyCommand = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyEnvs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProxyEnvs == nil {
				m.ProxyEnvs = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMachines
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMachines
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMachines
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMachines
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMachines
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMachines
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthMachines
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMachines(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMachines
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ProxyEnvs[mapkey] = mapvalue
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Live", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Live = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttachDiskRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttachDiskRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttachDiskRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			m.Driver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Driver |= types.DiskDriver(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IopsRd", wireType)
			}
			m.IopsRd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IopsRd |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IopsWr", wireType)
			}
			m.IopsWr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IopsWr |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bootindex", wireType)
			}
			m.Bootindex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bootindex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyCommand", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyCommand = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyEnvs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProxyEnvs == nil {
				m.ProxyEnvs = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMachines
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMachines
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMachines
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMachines
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMachines
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMachines
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthMachines
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMachines(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthMachines
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ProxyEnvs[mapkey] = mapvalue
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Live", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Live = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DetachDiskRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DetachDiskRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DetachDiskRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Live", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Live = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetDiskLimitsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetDiskLimitsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetDiskLimitsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IopsRd", wireType)
			}
			m.IopsRd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IopsRd |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IopsWr", wireType)
			}
			m.IopsWr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IopsWr |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Live", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Live = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveDiskBitmapRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveDiskBitmapRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveDiskBitmapRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResizeQemuBlockdevRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResizeQemuBlockdevRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResizeQemuBlockdevRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttachNetIfaceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttachNetIfaceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttachNetIfaceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ifname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ifname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			m.Driver = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Driver |= types.NetIfaceDriver(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HwAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HwAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfupScript", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IfupScript = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfdownScript", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IfdownScript = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Live", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Live = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DetachNetIfaceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DetachNetIfaceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DetachNetIfaceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ifname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ifname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Live", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Live = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetNetIfaceScriptRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetNetIfaceScriptRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetNetIfaceScriptRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ifname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ifname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetNetIfaceLinkRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetNetIfaceLinkRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetNetIfaceLinkRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ifname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ifname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= types.NetIfaceLinkState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttachChannelRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttachChannelRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttachChannelRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vsock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AttachChannelRequest_VirtioVSock{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Channel = &AttachChannelRequest_Vsock{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialPort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AttachChannelRequest_VirtioSerialPort{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Channel = &AttachChannelRequest_SerialPort{v}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Live", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Live = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttachChannelRequest_VirtioVSock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtioVSock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtioVSock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContextID", wireType)
			}
			m.ContextID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContextID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttachChannelRequest_VirtioSerialPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtioSerialPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtioSerialPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortGuestName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortGuestName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DetachChannelRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DetachChannelRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DetachChannelRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vsock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DetachChannelRequest_VirtioVSock{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Channel = &DetachChannelRequest_Vsock{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialPort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DetachChannelRequest_VirtioSerialPort{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Channel = &DetachChannelRequest_SerialPort{v}
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Live", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Live = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DetachChannelRequest_VirtioVSock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtioVSock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtioVSock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DetachChannelRequest_VirtioSerialPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtioSerialPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtioSerialPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttachCloudInitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttachCloudInitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttachCloudInitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DetachCloudInitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DetachCloudInitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DetachCloudInitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeCloudInitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeCloudInitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeCloudInitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartDiskBackupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartDiskBackupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartDiskBackupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Incremental", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Incremental = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearBitmap", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClearBitmap = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartBackupResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartBackupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartBackupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartMigrationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartMigrationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartMigrationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstServer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstServer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disks", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Disks = append(m.Disks, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overrides", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Overrides == nil {
				m.Overrides = &types.MigrationOverrides{}
			}
			if err := m.Overrides.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateDisks", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateDisks = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveAfter", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RemoveAfter = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartMigrationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartMigrationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartMigrationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetExternalKernelRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetExternalKernelRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetExternalKernelRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Initrd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Initrd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmdline", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cmdline = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modiso", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMachines
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMachines
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Modiso = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveConf", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RemoveConf = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMachines(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMachines
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMachines(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMachines
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMachines
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMachines
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMachines
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMachines
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMachines        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMachines          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMachines = fmt.Errorf("proto: unexpected end of group")
)
