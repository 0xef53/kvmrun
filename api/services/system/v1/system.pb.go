// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: services/system/v1/system.proto

package system

import (
	context "context"
	fmt "fmt"
	types "github.com/0xef53/kvmrun/api/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type RegisterQemuInstanceRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	MemActual            int64    `protobuf:"varint,2,opt,name=mem_actual,json=memActual,proto3" json:"mem_actual,omitempty"`
	PID                  int32    `protobuf:"varint,3,opt,name=pid,proto3" json:"pid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RegisterQemuInstanceRequest) Reset()         { *m = RegisterQemuInstanceRequest{} }
func (m *RegisterQemuInstanceRequest) String() string { return proto.CompactTextString(m) }
func (*RegisterQemuInstanceRequest) ProtoMessage()    {}
func (*RegisterQemuInstanceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce2ea51697fbb8e8, []int{0}
}
func (m *RegisterQemuInstanceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterQemuInstanceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterQemuInstanceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterQemuInstanceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterQemuInstanceRequest.Merge(m, src)
}
func (m *RegisterQemuInstanceRequest) XXX_Size() int {
	return m.Size()
}
func (m *RegisterQemuInstanceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterQemuInstanceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterQemuInstanceRequest proto.InternalMessageInfo

func (m *RegisterQemuInstanceRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RegisterQemuInstanceRequest) GetMemActual() int64 {
	if m != nil {
		return m.MemActual
	}
	return 0
}

func (m *RegisterQemuInstanceRequest) GetPID() int32 {
	if m != nil {
		return m.PID
	}
	return 0
}

type RegisterQemuInstanceResponse struct {
	TaskKey              string   `protobuf:"bytes,1,opt,name=task_key,json=taskKey,proto3" json:"task_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RegisterQemuInstanceResponse) Reset()         { *m = RegisterQemuInstanceResponse{} }
func (m *RegisterQemuInstanceResponse) String() string { return proto.CompactTextString(m) }
func (*RegisterQemuInstanceResponse) ProtoMessage()    {}
func (*RegisterQemuInstanceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce2ea51697fbb8e8, []int{1}
}
func (m *RegisterQemuInstanceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterQemuInstanceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterQemuInstanceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterQemuInstanceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterQemuInstanceResponse.Merge(m, src)
}
func (m *RegisterQemuInstanceResponse) XXX_Size() int {
	return m.Size()
}
func (m *RegisterQemuInstanceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterQemuInstanceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterQemuInstanceResponse proto.InternalMessageInfo

func (m *RegisterQemuInstanceResponse) GetTaskKey() string {
	if m != nil {
		return m.TaskKey
	}
	return ""
}

type UnregisterQemuInstanceRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnregisterQemuInstanceRequest) Reset()         { *m = UnregisterQemuInstanceRequest{} }
func (m *UnregisterQemuInstanceRequest) String() string { return proto.CompactTextString(m) }
func (*UnregisterQemuInstanceRequest) ProtoMessage()    {}
func (*UnregisterQemuInstanceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce2ea51697fbb8e8, []int{2}
}
func (m *UnregisterQemuInstanceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnregisterQemuInstanceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnregisterQemuInstanceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnregisterQemuInstanceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnregisterQemuInstanceRequest.Merge(m, src)
}
func (m *UnregisterQemuInstanceRequest) XXX_Size() int {
	return m.Size()
}
func (m *UnregisterQemuInstanceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnregisterQemuInstanceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnregisterQemuInstanceRequest proto.InternalMessageInfo

func (m *UnregisterQemuInstanceRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type StopQemuInstanceRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	GracefulTimeout      int32    `protobuf:"varint,2,opt,name=graceful_timeout,json=gracefulTimeout,proto3" json:"graceful_timeout,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StopQemuInstanceRequest) Reset()         { *m = StopQemuInstanceRequest{} }
func (m *StopQemuInstanceRequest) String() string { return proto.CompactTextString(m) }
func (*StopQemuInstanceRequest) ProtoMessage()    {}
func (*StopQemuInstanceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce2ea51697fbb8e8, []int{3}
}
func (m *StopQemuInstanceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StopQemuInstanceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StopQemuInstanceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StopQemuInstanceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StopQemuInstanceRequest.Merge(m, src)
}
func (m *StopQemuInstanceRequest) XXX_Size() int {
	return m.Size()
}
func (m *StopQemuInstanceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StopQemuInstanceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StopQemuInstanceRequest proto.InternalMessageInfo

func (m *StopQemuInstanceRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *StopQemuInstanceRequest) GetGracefulTimeout() int32 {
	if m != nil {
		return m.GracefulTimeout
	}
	return 0
}

type StartIncomingMachineRequest struct {
	Name                 string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Manifest             []byte            `protobuf:"bytes,2,opt,name=manifest,proto3" json:"manifest,omitempty"`
	Disks                map[string]uint64 `protobuf:"bytes,3,rep,name=disks,proto3" json:"disks,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	ExtraFiles           map[string][]byte `protobuf:"bytes,4,rep,name=extra_files,json=extraFiles,proto3" json:"extra_files,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	CreateDisks          bool              `protobuf:"varint,5,opt,name=create_disks,json=createDisks,proto3" json:"create_disks,omitempty"`
	ListenAddr           string            `protobuf:"bytes,6,opt,name=listen_addr,json=listenAddr,proto3" json:"listen_addr,omitempty"`
	TurnOffAfter         bool              `protobuf:"varint,7,opt,name=turn_off_after,json=turnOffAfter,proto3" json:"turn_off_after,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *StartIncomingMachineRequest) Reset()         { *m = StartIncomingMachineRequest{} }
func (m *StartIncomingMachineRequest) String() string { return proto.CompactTextString(m) }
func (*StartIncomingMachineRequest) ProtoMessage()    {}
func (*StartIncomingMachineRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce2ea51697fbb8e8, []int{4}
}
func (m *StartIncomingMachineRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartIncomingMachineRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartIncomingMachineRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartIncomingMachineRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartIncomingMachineRequest.Merge(m, src)
}
func (m *StartIncomingMachineRequest) XXX_Size() int {
	return m.Size()
}
func (m *StartIncomingMachineRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StartIncomingMachineRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StartIncomingMachineRequest proto.InternalMessageInfo

func (m *StartIncomingMachineRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *StartIncomingMachineRequest) GetManifest() []byte {
	if m != nil {
		return m.Manifest
	}
	return nil
}

func (m *StartIncomingMachineRequest) GetDisks() map[string]uint64 {
	if m != nil {
		return m.Disks
	}
	return nil
}

func (m *StartIncomingMachineRequest) GetExtraFiles() map[string][]byte {
	if m != nil {
		return m.ExtraFiles
	}
	return nil
}

func (m *StartIncomingMachineRequest) GetCreateDisks() bool {
	if m != nil {
		return m.CreateDisks
	}
	return false
}

func (m *StartIncomingMachineRequest) GetListenAddr() string {
	if m != nil {
		return m.ListenAddr
	}
	return ""
}

func (m *StartIncomingMachineRequest) GetTurnOffAfter() bool {
	if m != nil {
		return m.TurnOffAfter
	}
	return false
}

type StartIncomingMachineResponse struct {
	Requisites           *types.IncomingMachineRequisites `protobuf:"bytes,1,opt,name=requisites,proto3" json:"requisites,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *StartIncomingMachineResponse) Reset()         { *m = StartIncomingMachineResponse{} }
func (m *StartIncomingMachineResponse) String() string { return proto.CompactTextString(m) }
func (*StartIncomingMachineResponse) ProtoMessage()    {}
func (*StartIncomingMachineResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce2ea51697fbb8e8, []int{5}
}
func (m *StartIncomingMachineResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartIncomingMachineResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartIncomingMachineResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartIncomingMachineResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartIncomingMachineResponse.Merge(m, src)
}
func (m *StartIncomingMachineResponse) XXX_Size() int {
	return m.Size()
}
func (m *StartIncomingMachineResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StartIncomingMachineResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StartIncomingMachineResponse proto.InternalMessageInfo

func (m *StartIncomingMachineResponse) GetRequisites() *types.IncomingMachineRequisites {
	if m != nil {
		return m.Requisites
	}
	return nil
}

type DiskBackendProxyRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DiskBackendProxyRequest) Reset()         { *m = DiskBackendProxyRequest{} }
func (m *DiskBackendProxyRequest) String() string { return proto.CompactTextString(m) }
func (*DiskBackendProxyRequest) ProtoMessage()    {}
func (*DiskBackendProxyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce2ea51697fbb8e8, []int{6}
}
func (m *DiskBackendProxyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiskBackendProxyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiskBackendProxyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiskBackendProxyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiskBackendProxyRequest.Merge(m, src)
}
func (m *DiskBackendProxyRequest) XXX_Size() int {
	return m.Size()
}
func (m *DiskBackendProxyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DiskBackendProxyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DiskBackendProxyRequest proto.InternalMessageInfo

func (m *DiskBackendProxyRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func init() {
	proto.RegisterType((*RegisterQemuInstanceRequest)(nil), "kvmrun.api.services.system.v1.RegisterQemuInstanceRequest")
	proto.RegisterType((*RegisterQemuInstanceResponse)(nil), "kvmrun.api.services.system.v1.RegisterQemuInstanceResponse")
	proto.RegisterType((*UnregisterQemuInstanceRequest)(nil), "kvmrun.api.services.system.v1.UnregisterQemuInstanceRequest")
	proto.RegisterType((*StopQemuInstanceRequest)(nil), "kvmrun.api.services.system.v1.StopQemuInstanceRequest")
	proto.RegisterType((*StartIncomingMachineRequest)(nil), "kvmrun.api.services.system.v1.StartIncomingMachineRequest")
	proto.RegisterMapType((map[string]uint64)(nil), "kvmrun.api.services.system.v1.StartIncomingMachineRequest.DisksEntry")
	proto.RegisterMapType((map[string][]byte)(nil), "kvmrun.api.services.system.v1.StartIncomingMachineRequest.ExtraFilesEntry")
	proto.RegisterType((*StartIncomingMachineResponse)(nil), "kvmrun.api.services.system.v1.StartIncomingMachineResponse")
	proto.RegisterType((*DiskBackendProxyRequest)(nil), "kvmrun.api.services.system.v1.DiskBackendProxyRequest")
}

func init() { proto.RegisterFile("services/system/v1/system.proto", fileDescriptor_ce2ea51697fbb8e8) }

var fileDescriptor_ce2ea51697fbb8e8 = []byte{
	// 725 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0xdd, 0x4e, 0xe3, 0x56,
	0x10, 0xc6, 0x98, 0xf0, 0x33, 0x49, 0x0b, 0x3d, 0xa2, 0x10, 0xc2, 0x5f, 0x6a, 0xf5, 0x22, 0x55,
	0x85, 0x5d, 0x40, 0x45, 0x14, 0xda, 0x0b, 0x10, 0xa9, 0x44, 0x51, 0x55, 0xea, 0xb4, 0xd2, 0x6a,
	0xf7, 0xc2, 0x3a, 0xd8, 0x63, 0x63, 0x39, 0xfe, 0xe1, 0x9c, 0xe3, 0x88, 0x3c, 0xc6, 0xbe, 0xd5,
	0x5e, 0xee, 0x13, 0xac, 0x56, 0xd1, 0x3e, 0xc5, 0x5e, 0xad, 0x7c, 0x4e, 0x80, 0x88, 0xcd, 0x3a,
	0xfb, 0xa3, 0xbd, 0x89, 0x66, 0x3e, 0xcd, 0x7c, 0x93, 0x99, 0xf3, 0xcd, 0x18, 0xb6, 0x39, 0xb2,
	0x5e, 0xe8, 0x22, 0xb7, 0x78, 0x9f, 0x0b, 0x8c, 0xad, 0xde, 0xee, 0xd0, 0x32, 0x33, 0x96, 0x8a,
	0x94, 0x6c, 0x46, 0xbd, 0x98, 0xe5, 0x89, 0x49, 0xb3, 0xd0, 0xbc, 0x8b, 0x35, 0x87, 0x11, 0xbd,
	0xdd, 0xc6, 0x7a, 0x90, 0xa6, 0x41, 0x17, 0x2d, 0x19, 0x7c, 0x95, 0xfb, 0x16, 0xc6, 0x99, 0xe8,
	0xab, 0xdc, 0xc6, 0x4e, 0x10, 0x8a, 0xeb, 0xfc, 0xca, 0x74, 0xd3, 0xd8, 0x0a, 0xd2, 0x20, 0x7d,
	0x88, 0x2a, 0x3c, 0xe9, 0x48, 0x6b, 0x18, 0xfe, 0x9d, 0xe8, 0x67, 0xc8, 0x2d, 0xf9, 0xab, 0x20,
	0x23, 0x82, 0x75, 0x1b, 0x83, 0x90, 0x0b, 0x64, 0xff, 0x62, 0x9c, 0x9f, 0x27, 0x5c, 0xd0, 0xc4,
	0x45, 0x1b, 0x6f, 0x72, 0xe4, 0x82, 0x10, 0x98, 0x49, 0x68, 0x8c, 0x75, 0xad, 0xa9, 0xb5, 0x16,
	0x6c, 0x69, 0x93, 0x4d, 0x80, 0x18, 0x63, 0x87, 0xba, 0x22, 0xa7, 0xdd, 0xfa, 0x74, 0x53, 0x6b,
	0xe9, 0xf6, 0x42, 0x8c, 0xf1, 0x89, 0x04, 0xc8, 0x1a, 0xe8, 0x59, 0xe8, 0xd5, 0xf5, 0xa6, 0xd6,
	0xaa, 0x9c, 0xce, 0x0d, 0x5e, 0x6d, 0xeb, 0x97, 0xe7, 0x67, 0x76, 0x81, 0x19, 0xbf, 0xc1, 0xc6,
	0xf8, 0x62, 0x3c, 0x4b, 0x13, 0x8e, 0x64, 0x0d, 0xe6, 0x05, 0xe5, 0x91, 0x13, 0x61, 0x7f, 0x58,
	0x71, 0xae, 0xf0, 0x2f, 0xb0, 0x6f, 0xec, 0xc3, 0xe6, 0xff, 0x09, 0xfb, 0xb4, 0x7f, 0x6a, 0x3c,
	0x81, 0xd5, 0x8e, 0x48, 0xb3, 0x8f, 0x6d, 0xec, 0x27, 0x58, 0x0a, 0x18, 0x75, 0xd1, 0xcf, 0xbb,
	0x8e, 0x08, 0x63, 0x4c, 0x73, 0x21, 0xdb, 0xab, 0xd8, 0x8b, 0x77, 0xf8, 0x7f, 0x0a, 0x36, 0xde,
	0xea, 0xb0, 0xde, 0x11, 0x94, 0x89, 0xf3, 0xc4, 0x4d, 0xe3, 0x30, 0x09, 0xfe, 0xa6, 0xee, 0x75,
	0x98, 0x94, 0xd2, 0x37, 0x60, 0x3e, 0xa6, 0x49, 0xe8, 0x23, 0x57, 0xb4, 0x35, 0xfb, 0xde, 0x27,
	0xcf, 0xa0, 0xe2, 0x85, 0x3c, 0xe2, 0x75, 0xbd, 0xa9, 0xb7, 0xaa, 0x7b, 0x6d, 0xb3, 0x54, 0x14,
	0x66, 0x49, 0x69, 0xf3, 0xac, 0xe0, 0x69, 0x27, 0x82, 0xf5, 0x6d, 0xc5, 0x49, 0x22, 0xa8, 0xe2,
	0xad, 0x60, 0xd4, 0xf1, 0xc3, 0x2e, 0xf2, 0xfa, 0x8c, 0x2c, 0xf1, 0xd7, 0x17, 0x94, 0x68, 0x17,
	0x6c, 0x7f, 0x16, 0x64, 0xaa, 0x0e, 0xe0, 0x3d, 0x40, 0x7e, 0x80, 0x9a, 0xcb, 0x90, 0x0a, 0x74,
	0x54, 0x43, 0x95, 0xa6, 0xd6, 0x9a, 0xb7, 0xab, 0x0a, 0x93, 0xff, 0x8d, 0x6c, 0x43, 0xb5, 0x5b,
	0xbc, 0x63, 0xe2, 0x50, 0xcf, 0x63, 0xf5, 0x59, 0x39, 0x23, 0x50, 0xd0, 0x89, 0xe7, 0x31, 0xf2,
	0x23, 0x7c, 0x2b, 0x72, 0x96, 0x38, 0xa9, 0xef, 0x3b, 0xd4, 0x17, 0xc8, 0xea, 0x73, 0x92, 0xa5,
	0x56, 0xa0, 0xff, 0xf8, 0xfe, 0x49, 0x81, 0x35, 0x0e, 0x01, 0x1e, 0x7a, 0x25, 0x4b, 0xa0, 0x3f,
	0xc8, 0xa6, 0x30, 0xc9, 0x32, 0x54, 0x7a, 0xb4, 0x9b, 0xa3, 0x1c, 0xf6, 0x8c, 0xad, 0x9c, 0xa3,
	0xe9, 0x43, 0xad, 0xf1, 0x07, 0x2c, 0x3e, 0x6a, 0x61, 0x52, 0x7a, 0x6d, 0x24, 0xdd, 0x88, 0x60,
	0x63, 0xfc, 0x74, 0x86, 0x32, 0xbe, 0x00, 0x60, 0x78, 0x93, 0x87, 0x3c, 0x14, 0xc8, 0x25, 0x65,
	0x75, 0xef, 0xe7, 0xd1, 0x71, 0xab, 0x05, 0x1c, 0x33, 0x5c, 0x95, 0x62, 0x8f, 0xa4, 0x1b, 0x3b,
	0xb0, 0x5a, 0x74, 0x79, 0x4a, 0xdd, 0x08, 0x13, 0xef, 0x92, 0xa5, 0xb7, 0xfd, 0x12, 0x91, 0xed,
	0xbd, 0xa9, 0xc0, 0x37, 0x1d, 0xf9, 0x88, 0x1d, 0xf5, 0xa6, 0xe4, 0xb9, 0x06, 0xcb, 0xe3, 0xb6,
	0x8e, 0x1c, 0x4d, 0x50, 0x40, 0xc9, 0x5d, 0x68, 0x1c, 0x7f, 0x56, 0xae, 0x9a, 0x8f, 0x31, 0x45,
	0x32, 0x58, 0x19, 0xbf, 0xcd, 0xe4, 0xf7, 0x09, 0xc4, 0xa5, 0x47, 0xa0, 0xb1, 0x62, 0xaa, 0x6b,
	0x69, 0xde, 0xdd, 0x41, 0xb3, 0x5d, 0x5c, 0x4b, 0x63, 0x8a, 0x78, 0xb0, 0xf4, 0xf8, 0x14, 0x90,
	0x83, 0x89, 0x2b, 0x30, 0xf6, 0x76, 0x94, 0x54, 0x29, 0x66, 0x3d, 0x4e, 0x1a, 0x13, 0x67, 0x5d,
	0xb2, 0x6d, 0x13, 0x67, 0x5d, 0xa6, 0x45, 0x63, 0x8a, 0x84, 0xf0, 0xbd, 0x8c, 0x78, 0xac, 0xa2,
	0x89, 0xed, 0x7f, 0x40, 0x76, 0x25, 0xed, 0x5f, 0x17, 0xdd, 0xa7, 0xd9, 0xd7, 0xaf, 0x74, 0x7a,
	0xf6, 0x62, 0xb0, 0xa5, 0xbd, 0x1c, 0x6c, 0x69, 0xaf, 0x07, 0x5b, 0xda, 0xd3, 0x83, 0x91, 0xcf,
	0xe0, 0x2f, 0xb7, 0xe8, 0xff, 0xba, 0x6f, 0xa9, 0x82, 0x16, 0xcd, 0x42, 0xeb, 0xfd, 0x0f, 0xf0,
	0xb1, 0xb2, 0xae, 0x66, 0x25, 0xef, 0xfe, 0xbb, 0x00, 0x00, 0x00, 0xff, 0xff, 0xee, 0xbd, 0xf9,
	0x3a, 0xa4, 0x07, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SystemServiceClient is the client API for SystemService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SystemServiceClient interface {
	RegisterQemuInstance(ctx context.Context, in *RegisterQemuInstanceRequest, opts ...grpc.CallOption) (*RegisterQemuInstanceResponse, error)
	UnregisterQemuInstance(ctx context.Context, in *UnregisterQemuInstanceRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	StopQemuInstance(ctx context.Context, in *StopQemuInstanceRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	StartIncomingMachine(ctx context.Context, in *StartIncomingMachineRequest, opts ...grpc.CallOption) (*StartIncomingMachineResponse, error)
	StartDiskBackendProxy(ctx context.Context, in *DiskBackendProxyRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	StopDiskBackendProxy(ctx context.Context, in *DiskBackendProxyRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type systemServiceClient struct {
	cc *grpc.ClientConn
}

func NewSystemServiceClient(cc *grpc.ClientConn) SystemServiceClient {
	return &systemServiceClient{cc}
}

func (c *systemServiceClient) RegisterQemuInstance(ctx context.Context, in *RegisterQemuInstanceRequest, opts ...grpc.CallOption) (*RegisterQemuInstanceResponse, error) {
	out := new(RegisterQemuInstanceResponse)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.system.v1.SystemService/RegisterQemuInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemServiceClient) UnregisterQemuInstance(ctx context.Context, in *UnregisterQemuInstanceRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.system.v1.SystemService/UnregisterQemuInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemServiceClient) StopQemuInstance(ctx context.Context, in *StopQemuInstanceRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.system.v1.SystemService/StopQemuInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemServiceClient) StartIncomingMachine(ctx context.Context, in *StartIncomingMachineRequest, opts ...grpc.CallOption) (*StartIncomingMachineResponse, error) {
	out := new(StartIncomingMachineResponse)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.system.v1.SystemService/StartIncomingMachine", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemServiceClient) StartDiskBackendProxy(ctx context.Context, in *DiskBackendProxyRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.system.v1.SystemService/StartDiskBackendProxy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemServiceClient) StopDiskBackendProxy(ctx context.Context, in *DiskBackendProxyRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/kvmrun.api.services.system.v1.SystemService/StopDiskBackendProxy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SystemServiceServer is the server API for SystemService service.
type SystemServiceServer interface {
	RegisterQemuInstance(context.Context, *RegisterQemuInstanceRequest) (*RegisterQemuInstanceResponse, error)
	UnregisterQemuInstance(context.Context, *UnregisterQemuInstanceRequest) (*empty.Empty, error)
	StopQemuInstance(context.Context, *StopQemuInstanceRequest) (*empty.Empty, error)
	StartIncomingMachine(context.Context, *StartIncomingMachineRequest) (*StartIncomingMachineResponse, error)
	StartDiskBackendProxy(context.Context, *DiskBackendProxyRequest) (*empty.Empty, error)
	StopDiskBackendProxy(context.Context, *DiskBackendProxyRequest) (*empty.Empty, error)
}

// UnimplementedSystemServiceServer can be embedded to have forward compatible implementations.
type UnimplementedSystemServiceServer struct {
}

func (*UnimplementedSystemServiceServer) RegisterQemuInstance(ctx context.Context, req *RegisterQemuInstanceRequest) (*RegisterQemuInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterQemuInstance not implemented")
}
func (*UnimplementedSystemServiceServer) UnregisterQemuInstance(ctx context.Context, req *UnregisterQemuInstanceRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterQemuInstance not implemented")
}
func (*UnimplementedSystemServiceServer) StopQemuInstance(ctx context.Context, req *StopQemuInstanceRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopQemuInstance not implemented")
}
func (*UnimplementedSystemServiceServer) StartIncomingMachine(ctx context.Context, req *StartIncomingMachineRequest) (*StartIncomingMachineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartIncomingMachine not implemented")
}
func (*UnimplementedSystemServiceServer) StartDiskBackendProxy(ctx context.Context, req *DiskBackendProxyRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartDiskBackendProxy not implemented")
}
func (*UnimplementedSystemServiceServer) StopDiskBackendProxy(ctx context.Context, req *DiskBackendProxyRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopDiskBackendProxy not implemented")
}

func RegisterSystemServiceServer(s *grpc.Server, srv SystemServiceServer) {
	s.RegisterService(&_SystemService_serviceDesc, srv)
}

func _SystemService_RegisterQemuInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterQemuInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServiceServer).RegisterQemuInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.system.v1.SystemService/RegisterQemuInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServiceServer).RegisterQemuInstance(ctx, req.(*RegisterQemuInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemService_UnregisterQemuInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterQemuInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServiceServer).UnregisterQemuInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.system.v1.SystemService/UnregisterQemuInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServiceServer).UnregisterQemuInstance(ctx, req.(*UnregisterQemuInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemService_StopQemuInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopQemuInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServiceServer).StopQemuInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.system.v1.SystemService/StopQemuInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServiceServer).StopQemuInstance(ctx, req.(*StopQemuInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemService_StartIncomingMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartIncomingMachineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServiceServer).StartIncomingMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.system.v1.SystemService/StartIncomingMachine",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServiceServer).StartIncomingMachine(ctx, req.(*StartIncomingMachineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemService_StartDiskBackendProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiskBackendProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServiceServer).StartDiskBackendProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.system.v1.SystemService/StartDiskBackendProxy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServiceServer).StartDiskBackendProxy(ctx, req.(*DiskBackendProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemService_StopDiskBackendProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiskBackendProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServiceServer).StopDiskBackendProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kvmrun.api.services.system.v1.SystemService/StopDiskBackendProxy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServiceServer).StopDiskBackendProxy(ctx, req.(*DiskBackendProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SystemService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kvmrun.api.services.system.v1.SystemService",
	HandlerType: (*SystemServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterQemuInstance",
			Handler:    _SystemService_RegisterQemuInstance_Handler,
		},
		{
			MethodName: "UnregisterQemuInstance",
			Handler:    _SystemService_UnregisterQemuInstance_Handler,
		},
		{
			MethodName: "StopQemuInstance",
			Handler:    _SystemService_StopQemuInstance_Handler,
		},
		{
			MethodName: "StartIncomingMachine",
			Handler:    _SystemService_StartIncomingMachine_Handler,
		},
		{
			MethodName: "StartDiskBackendProxy",
			Handler:    _SystemService_StartDiskBackendProxy_Handler,
		},
		{
			MethodName: "StopDiskBackendProxy",
			Handler:    _SystemService_StopDiskBackendProxy_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services/system/v1/system.proto",
}

func (m *RegisterQemuInstanceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterQemuInstanceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterQemuInstanceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PID != 0 {
		i = encodeVarintSystem(dAtA, i, uint64(m.PID))
		i--
		dAtA[i] = 0x18
	}
	if m.MemActual != 0 {
		i = encodeVarintSystem(dAtA, i, uint64(m.MemActual))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSystem(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterQemuInstanceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterQemuInstanceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterQemuInstanceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TaskKey) > 0 {
		i -= len(m.TaskKey)
		copy(dAtA[i:], m.TaskKey)
		i = encodeVarintSystem(dAtA, i, uint64(len(m.TaskKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnregisterQemuInstanceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnregisterQemuInstanceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnregisterQemuInstanceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSystem(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StopQemuInstanceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopQemuInstanceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StopQemuInstanceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GracefulTimeout != 0 {
		i = encodeVarintSystem(dAtA, i, uint64(m.GracefulTimeout))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSystem(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StartIncomingMachineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartIncomingMachineRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartIncomingMachineRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TurnOffAfter {
		i--
		if m.TurnOffAfter {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.ListenAddr) > 0 {
		i -= len(m.ListenAddr)
		copy(dAtA[i:], m.ListenAddr)
		i = encodeVarintSystem(dAtA, i, uint64(len(m.ListenAddr)))
		i--
		dAtA[i] = 0x32
	}
	if m.CreateDisks {
		i--
		if m.CreateDisks {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.ExtraFiles) > 0 {
		for k := range m.ExtraFiles {
			v := m.ExtraFiles[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintSystem(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSystem(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSystem(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Disks) > 0 {
		for k := range m.Disks {
			v := m.Disks[k]
			baseI := i
			i = encodeVarintSystem(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSystem(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSystem(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Manifest) > 0 {
		i -= len(m.Manifest)
		copy(dAtA[i:], m.Manifest)
		i = encodeVarintSystem(dAtA, i, uint64(len(m.Manifest)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSystem(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StartIncomingMachineResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartIncomingMachineResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartIncomingMachineResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Requisites != nil {
		{
			size, err := m.Requisites.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSystem(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DiskBackendProxyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiskBackendProxyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiskBackendProxyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSystem(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintSystem(dAtA []byte, offset int, v uint64) int {
	offset -= sovSystem(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RegisterQemuInstanceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSystem(uint64(l))
	}
	if m.MemActual != 0 {
		n += 1 + sovSystem(uint64(m.MemActual))
	}
	if m.PID != 0 {
		n += 1 + sovSystem(uint64(m.PID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RegisterQemuInstanceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TaskKey)
	if l > 0 {
		n += 1 + l + sovSystem(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnregisterQemuInstanceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSystem(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StopQemuInstanceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSystem(uint64(l))
	}
	if m.GracefulTimeout != 0 {
		n += 1 + sovSystem(uint64(m.GracefulTimeout))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StartIncomingMachineRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSystem(uint64(l))
	}
	l = len(m.Manifest)
	if l > 0 {
		n += 1 + l + sovSystem(uint64(l))
	}
	if len(m.Disks) > 0 {
		for k, v := range m.Disks {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSystem(uint64(len(k))) + 1 + sovSystem(uint64(v))
			n += mapEntrySize + 1 + sovSystem(uint64(mapEntrySize))
		}
	}
	if len(m.ExtraFiles) > 0 {
		for k, v := range m.ExtraFiles {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovSystem(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovSystem(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSystem(uint64(mapEntrySize))
		}
	}
	if m.CreateDisks {
		n += 2
	}
	l = len(m.ListenAddr)
	if l > 0 {
		n += 1 + l + sovSystem(uint64(l))
	}
	if m.TurnOffAfter {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StartIncomingMachineResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Requisites != nil {
		l = m.Requisites.Size()
		n += 1 + l + sovSystem(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiskBackendProxyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSystem(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSystem(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSystem(x uint64) (n int) {
	return sovSystem(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RegisterQemuInstanceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSystem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterQemuInstanceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterQemuInstanceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSystem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSystem
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSystem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemActual", wireType)
			}
			m.MemActual = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSystem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemActual |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PID", wireType)
			}
			m.PID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSystem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSystem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSystem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterQemuInstanceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSystem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterQemuInstanceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterQemuInstanceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSystem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSystem
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSystem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSystem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSystem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnregisterQemuInstanceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSystem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnregisterQemuInstanceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnregisterQemuInstanceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSystem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSystem
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSystem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSystem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSystem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopQemuInstanceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSystem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopQemuInstanceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopQemuInstanceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSystem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSystem
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSystem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GracefulTimeout", wireType)
			}
			m.GracefulTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSystem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GracefulTimeout |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSystem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSystem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartIncomingMachineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSystem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartIncomingMachineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartIncomingMachineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSystem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSystem
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSystem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manifest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSystem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSystem
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSystem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Manifest = append(m.Manifest[:0], dAtA[iNdEx:postIndex]...)
			if m.Manifest == nil {
				m.Manifest = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSystem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSystem
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSystem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Disks == nil {
				m.Disks = make(map[string]uint64)
			}
			var mapkey string
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSystem
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSystem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSystem
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSystem
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSystem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSystem(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSystem
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Disks[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraFiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSystem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSystem
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSystem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtraFiles == nil {
				m.ExtraFiles = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSystem
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSystem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSystem
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSystem
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSystem
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthSystem
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthSystem
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSystem(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSystem
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ExtraFiles[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateDisks", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSystem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateDisks = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListenAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSystem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSystem
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSystem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ListenAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TurnOffAfter", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSystem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TurnOffAfter = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSystem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSystem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartIncomingMachineResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSystem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartIncomingMachineResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartIncomingMachineResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requisites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSystem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSystem
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSystem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Requisites == nil {
				m.Requisites = &types.IncomingMachineRequisites{}
			}
			if err := m.Requisites.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSystem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSystem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiskBackendProxyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSystem
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiskBackendProxyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiskBackendProxyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSystem
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSystem
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSystem
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSystem(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSystem
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSystem(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSystem
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSystem
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSystem
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSystem
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSystem
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSystem
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSystem        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSystem          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSystem = fmt.Errorf("proto: unexpected end of group")
)
